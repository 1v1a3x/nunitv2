<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

    <Import Project="Microsoft.Common.targets" />
    <UsingTask TaskName="Microsoft.Build.Tasks.CreateCSharpManifestResourceName" AssemblyName="Microsoft.Build.Tasks, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"/>
    <PropertyGroup>
        <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildBinPath)\Microsoft.CSharp.targets</MSBuildAllProjects>
        <DefaultLanguageSourceExtension>.cs</DefaultLanguageSourceExtension>
        <Language>C#</Language>
    </PropertyGroup>

    <!--
    The CreateManifestResourceNames target create the manifest resource names from the .RESX
    files.

        [IN]
        @(ResxWithNoCulture) - The names the non-culture .RESX files.
        @(ResxWithCulture) - The names the culture .RESX files.
        @(NonResxWithNoCulture) - The names of the non-culture non-RESX files (like bitmaps, etc).
        @(NonResxWithCulture) - The names of the culture non-RESX files (like bitmaps, etc).

        [OUT]
        @(ManifestResourceWithNoCultureName) - The corresponding manifest resource name (.RESOURCE)
        @(ManifestResourceWithCultureName) - The corresponding manifest resource name (.RESOURCE)
        @(ManifestNonResxWithNoCulture) - The corresponding manifest resource name.
        @(ManifestNonResxWithCulture) - The corresponding manifest resource name.

    For C# applications the transformation is like:

        Resources1.resx => RootNamespace.Resources1 => Build into main assembly
        SubFolder\Resources1.resx => RootNamespace.SubFolder.Resources1 => Build into main assembly
        Resources1.fr.resx => RootNamespace.Resources1.fr => Build into satellite assembly
        Resources1.notaculture.resx => RootNamespace.Resources1.notaculture => Build into main assembly

    For other project systems, this transformation may be different.
    -->
    <PropertyGroup>
        <CreateManifestResourceNamesDependsOn></CreateManifestResourceNamesDependsOn>
    </PropertyGroup>
    <Target
        Name="CreateManifestResourceNames"
        Condition="'@(ResxWithNoCulture)@(ResxWithCulture)@(NonResxWithNoCulture)@(NonResxWithCulture)'!=''"
        DependsOnTargets="$(CreateManifestResourceNamesDependsOn)"
        >

        <Message Text="(in) The names the non-culture .RESX files: '@(ResxWithNoCulture)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) The names the culture .RESX files: '@(ResxWithCulture)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) The names of the non-culture non-RESX files: '@(NonResxWithNoCulture)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) The names of the culture non-RESX files: '@(NonResxWithCulture)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

        <!-- Create the target resource names for non-culture resx files. -->
        <CreateCSharpManifestResourceName Condition="'@(ResxWithNoCulture)'!=''"
              ResourceFiles="@(ResxWithNoCulture)"
              RootNamespace="$(RootNamespace)">

            <Output TaskParameter="ManifestResourceNames" ItemName="ManifestResourceWithNoCultureName"/>

        </CreateCSharpManifestResourceName>
        <Message Text="(out) Manifest-named resx files files with no culture: '@(ManifestResourceWithNoCultureName)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>


        <!-- Create the target resource names for culture resx files. -->
        <CreateCSharpManifestResourceName Condition="'@(ResxWithCulture)'!=''"
              ResourceFiles="@(ResxWithCulture)"
              RootNamespace="$(RootNamespace)">

            <Output TaskParameter="ManifestResourceNames" ItemName="ManifestResourceWithCultureName"/>

        </CreateCSharpManifestResourceName>
        <Message Text="(out) Manifest-named resx files with culture: '@(ManifestResourceWithCultureName)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

        <!-- Create the target resource names for non-culture non-resx files. -->
        <CreateCSharpManifestResourceName Condition="'@(NonResxWithNoCulture)'!=''"
              ResourceFiles="@(NonResxWithNoCulture)"
              RootNamespace="$(RootNamespace)">

            <Output TaskParameter="ManifestResourceNames" ItemName="ManifestNonResxWithNoCulture"/>

        </CreateCSharpManifestResourceName>
        <Message Text="(out) Manifest-named non-culture non-*.resx files: '@(ManifestNonResxWithNoCulture)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

        <!-- Create the target resource names for culture non-resx files. -->
        <CreateCSharpManifestResourceName Condition="'@(NonResxWithCulture)'!=''"
              ResourceFiles="@(NonResxWithCulture)"
              RootNamespace="$(RootNamespace)">

            <Output TaskParameter="ManifestResourceNames" ItemName="ManifestNonResxWithCulture"/>

        </CreateCSharpManifestResourceName>
        <Message Text="(out) Manifest-named culture non-*.resx files: '@(ManifestNonResxWithCulture)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

    </Target>

    <PropertyGroup>
        <DocFile>$(DocumentationFile)</DocFile>

        <!-- If we're building from inside VisualStudio, we want to always run the Compile target,
             so that the IDE's compilers have a chance to compile even if MSBuild thinks that the
             outputs on disk are up-to-date.  This is because in the IDE, one does not have to save
             the source files in the editors to disk before building.  This trick forces the Compile
             target to always run when inside the IDE. -->
        <NonExistentFile Condition=" '$(BuildingInsideVisualStudio)' == 'true' " >__NonExistentSubDir__\__NonExistentFile__</NonExistentFile>
        
        <!-- "None" is not technically a valid DebugType, so we can't pass it in as such
             to the compiler.  So here, we modify the properties so they make sense. -->
        <DebugSymbols Condition=" '$(DebugType)' == 'none' ">false</DebugSymbols>
        <DebugType    Condition=" '$(DebugType)' == 'none' "></DebugType>
    </PropertyGroup>

    <PropertyGroup>
        <CompileDependsOn>ResolveReferences;ResolveKeySource</CompileDependsOn>
    </PropertyGroup>
    <Target
        Name="Compile"
        Inputs="$(MSBuildAllProjects);
                @(Compile);
                @(ManifestResourceWithNoCulture);
                $(ApplicationIcon);
                $(AssemblyOriginatorKeyFile);
                @(ManifestNonResxWithNoCultureOnDisk);
                @(ReferencePath);
                @(CompiledLicenseFile)"
        Outputs="$(DocFile);
                 @(IntermediateAssembly);
                 $(NonExistentFile)"
        DependsOnTargets="$(CompileDependsOn)"
    >
        <Delete Files="@(IntermediateAssembly->'%(RelativeDir)%(Filename).pdb')"
                Condition=" '$(BuildingProject)' == 'true' "/>
        
        <Csc
              AdditionalLibPaths="$(AdditionalLibPaths)"
              AddModules="@(AddModules)"
              AllowUnsafeBlocks="$(AllowUnsafeBlocks)"
              BaseAddress="$(BaseAddress)"
              CheckForOverflowUnderflow="$(CheckForOverflowUnderflow)"
              CodePage="$(CodePage)"
              DebugType="$(DebugType)"
              DefineConstants="$(DefineConstants)"
              DelaySign="$(DelaySign)"
              DisabledWarnings="$(NoWarn)"
              DocumentationFile="$(DocFile)"
              EmitDebugInformation="$(DebugSymbols)"
              ErrorReport="$(ErrorReport)"
              FileAlignment="$(FileAlignment)"
              GenerateFullPaths="$(GenerateFullPaths)"
              KeyContainer="$(KeyContainerName)"
              KeyFile="$(KeyOriginatorFile)"
              LangVersion="$(LangVersion)"
              MainEntryPoint="$(StartupObject)"
              NoConfig="true"
              NoLogo="$(NoLogo)"
              NoStandardLib="$(NoStdLib)"
              Optimize="$(Optimize)"
              OutputAssembly="@(IntermediateAssembly)"
              Platform="$(PlatformTarget)"
              References="@(ReferencePath)"
              Resources="@(ManifestResourceWithNoCulture);@(ManifestNonResxWithNoCultureOnDisk);@(CompiledLicenseFile)"
              ResponseFile="$(CompilerResponseFile)"
              Sources="@(Compile)"
              TargetType="$(OutputType)"
              ToolPath="$(CscToolPath)"
              TreatWarningsAsErrors="$(TreatWarningsAsErrors)"
              UseHostCompilerIfAvailable="true"
              Utf8Output="$(Utf8Output)"
              WarningLevel="$(WarningLevel)"
              WarningsAsErrors="$(WarningsAsErrors)"
              WarningsNotAsErrors="$(WarningsNotAsErrors)"
              Win32Icon="$(ApplicationIcon)"
              Win32Resource="$(Win32Resource)"
              />

    </Target>


</Project>
