<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

    <UsingTask TaskName="Microsoft.Build.Tasks.FormatUrl" AssemblyName="Microsoft.Build.Tasks, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"/>
    <UsingTask TaskName="Microsoft.Build.Tasks.FormatVersion" AssemblyName="Microsoft.Build.Tasks, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"/>
    <UsingTask TaskName="Microsoft.Build.Tasks.ResolveManifestFiles" AssemblyName="Microsoft.Build.Tasks, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"/>
    <UsingTask TaskName="Microsoft.Build.Tasks.UpdateManifest" AssemblyName="Microsoft.Build.Tasks, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"/>
    <UsingTask TaskName="Microsoft.Build.Tasks.AssignTargetPath" AssemblyName="Microsoft.Build.Tasks, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"/>
    <UsingTask TaskName="Microsoft.VisualStudio.EnterpriseTools.MappingTool.CompileTime.ObjectRelationalValidator" AssemblyName="Microsoft.VisualStudio.EnterpriseTools.MappingTool"/>
    <UsingTask TaskName="Microsoft.Build.Tasks.FxCop" AssemblyName="Microsoft.Build.Tasks, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"/>  


    <Import Project="$(MSBuildProjectFullPath).user" Condition="Exists('$(MSBuildProjectFullPath).user')"/>

    <!-- Several properties must be set in the main project file, before using this .TARGETS file -->

    <Error  Condition="'$(AssemblyName)'==''"
            Text="The &quot;AssemblyName&quot; property is not set in project &quot;$(MSBuildProjectFile)&quot;.  Please set this in the project file before the &lt;Import&gt; of the .Targets file."/>

    <PropertyGroup>
        <Configuration Condition=" '$(Configuration)'=='' ">Debug</Configuration>      
        <DebugSymbols Condition=" '$(Configuration)_$(DebugSymbols)_$(DebugType)'=='Debug__'">true</DebugSymbols>
        <OutputType Condition=" '$(OutputType)' == '' ">exe</OutputType>
        <OutputPath Condition=" '$(OutputPath)' == '' ">bin\$(Configuration)\</OutputPath>
    </PropertyGroup>

    <!--
    Visual Studio Macros available from both integrated builds and from command line builds.

    The following properties are 'macros' that are available via Visual Studio for
    pre and post build steps.
    -->
    <PropertyGroup>
        <TargetExt Condition="'$(OutputType)'=='exe'">.exe</TargetExt>
        <TargetExt Condition="'$(OutputType)'=='winexe'">.exe</TargetExt>
        <TargetExt Condition="'$(OutputType)'=='library'">.dll</TargetExt>
        <TargetExt Condition="'$(OutputType)'=='module'">.netmodule</TargetExt>
    </PropertyGroup>

    <PropertyGroup>
        <OutDir Condition=" '$(OutDir)' == '' ">$(OutputPath)</OutDir>                                          <!-- Example, bin\Debug\ -->
        <ConfigurationName Condition=" '$(ConfigurationName)' == '' ">$(Configuration)</ConfigurationName>      <!-- Example, Debug -->
        <ProjectName Condition=" '$(ProjectName)' == '' ">$(MSBuildProjectName)</ProjectName>                   <!-- Example, MyProject -->
        <TargetName Condition=" '$(TargetName)' == '' ">$(AssemblyName)</TargetName>                            <!-- Example, MyAssembly -->
        <ProjectFileName Condition=" '$(ProjectFileName)' == '' ">$(MSBuildProjectFile)</ProjectFileName>       <!-- Example, MyProject.csproj -->
        <ProjectExt Condition=" '$(ProjectExt)' == '' ">$(MSBuildProjectExtension)</ProjectExt>                 <!-- Example, .csproj -->
        <TargetFileName Condition=" '$(TargetFileName)' == '' ">$(TargetName)$(TargetExt)</TargetFileName>      <!-- Example, MyAssembly.dll -->
    </PropertyGroup>

    <PropertyGroup>
        <TargetApplicationManifestFileName Condition="'$(OutputType)'=='library'">Native.$(AssemblyName).manifest</TargetApplicationManifestFileName>                       <!-- Example, Native.MyAssembly.manifest -->
        <TargetApplicationManifestFileName Condition="'$(OutputType)'=='winexe'">$(TargetFileName).manifest</TargetApplicationManifestFileName>                             <!-- Example, MyAssembly.exe.manifest -->
        <TargetApplicationManifestFileName Condition="'$(OutputType)'=='exe'">$(TargetFileName).manifest</TargetApplicationManifestFileName>                                <!-- Example, MyAssembly.exe.manifest -->
        <TargetDeployManifestFileName Condition="'$(TargetDeployManifestFileName)' == ''">$(AssemblyName).application</TargetDeployManifestFileName>  <!-- Example, MyAssembly.application -->
        <GenerateClickOnceManifests>$(GenerateManifests)</GenerateClickOnceManifests>

        <ManifestIdentitity>$(AssemblyName)</ManifestIdentitity>
        <ApplicationManifestIdentitity Condition="'$(OutputType)'=='library'">Native.$(AssemblyName)</ApplicationManifestIdentitity>
        <ApplicationManifestIdentitity Condition="'$(OutputType)'=='winexe'">$(ManifestIdentitity).exe</ApplicationManifestIdentitity>
        <ApplicationManifestIdentitity Condition="'$(OutputType)'=='exe'">$(ManifestIdentitity).exe</ApplicationManifestIdentitity>
        <DeployManifestIdentitity>$(ManifestIdentitity).application</DeployManifestIdentitity>
    </PropertyGroup>
    
     <!-- Create the output path as an item so that we can use %(FullPath) on it. -->
    <ItemGroup>
        <OutputPathItem Include="$(OutputPath)">
            <InProject>false</InProject>
        </OutputPathItem>
    </ItemGroup>

    <PropertyGroup>
        <!-- Example, c:\MyProjects\MyProject\bin\debug\ -->
        <!-- UNDONE.  Condition intentionally omitted on this one, because it causes problems
             when we pick up the value of an environment variable named TargetDir -->
        <TargetDir>@(OutputPathItem->'%(FullPath)')</TargetDir>

        <!-- Example, c:\MyProjects\MyProject\bin\debug\MyAssembly.dll -->
        <TargetPath Condition=" '$(TargetPath)' == '' ">@(OutputPathItem->'%(FullPath)$(TargetFileName)')</TargetPath>

        <!-- Example, c:\MyProjects\MyProject\ -->
        <ProjectDir Condition=" '$(ProjectDir)' == '' ">$(MSBuildProjectDirectory)\</ProjectDir>

        <!-- Example, c:\MyProjects\MyProject\MyProject.csproj -->
        <ProjectPath Condition=" '$(ProjectPath)' == '' ">$(ProjectDir)$(ProjectFileName)</ProjectPath>

        <!-- Example, .NET -->
        <PlatformName Condition=" '$(PlatformName)' == '' ">.NET</PlatformName>
    </PropertyGroup>

    <!--
    Visual Studio Macros available only from integrated builds.

    The following properties are 'macros' that are available via Visual Studio for
    pre and post build steps. However, they are not defined when building from
    the command line.
    -->
    <PropertyGroup>
        <DevEnvDir Condition="'$(DevEnvDir)'==''">*Undefined*</DevEnvDir>
        <SolutionName Condition="'$(SolutionName)'==''">*Undefined*</SolutionName>              <!-- Example, MySolution -->
        <SolutionFileName Condition="'$(SolutionFileName)'==''">*Undefined*</SolutionFileName>  <!-- Example, MySolution.sln -->
        <SolutionPath Condition="'$(SolutionPath)'==''">*Undefined*</SolutionPath>              <!-- Example, f:\MySolutions\MySolution\MySolution.sln -->
        <SolutionDir Condition="'$(SolutionDir)'==''">*Undefined*</SolutionDir>                 <!-- Example, f:\MySolutions\MySolution\ -->
        <SolutionExt Condition="'$(SolutionExt)'==''">*Undefined*</SolutionExt>                 <!-- Example, .sln -->
        <FxCopDir Condition="'$(FxCopDir)'==''">*Undefined*</FxCopDir>
    </PropertyGroup>

    <!--
    The following properties and items are used internally by this targets file.
    -->
    <PropertyGroup>
        <AutoUnifyAssemblyReferences>true</AutoUnifyAssemblyReferences>
        <AutoUnifyAssemblyReferences Condition="'$(OutputType)'=='exe'">false</AutoUnifyAssemblyReferences>
        <AutoUnifyAssemblyReferences Condition="'$(OutputType)'=='winexe'">false</AutoUnifyAssemblyReferences>
        <BaseOutputPath Condition="'$(BaseOutputPath)'==''">obj\</BaseOutputPath>
        <IntermediateOutputPath Condition="'$(IntermediateOutputPath)'==''">$(BaseOutputPath)$(Configuration)\</IntermediateOutputPath>
        <RootNamespaceDot Condition="'$(RootNamespace)'!=''">$(RootNamespace).</RootNamespaceDot>
    </PropertyGroup>

    <ItemGroup>
        <IntermediateAssembly Include="$(IntermediateOutputPath)$(TargetName)$(TargetExt)">
            <InProject>false</InProject>
        </IntermediateAssembly>

        <DocFileItem Include="$(DocFile)"  Condition="'$(DocFile)'!=''">
            <InProject>false</InProject>
        </DocFileItem>

        <FinalDocFile Include="@(DocFileItem->'$(OutDir)%(Filename)%(Extension)')">
            <InProject>false</InProject>
        </FinalDocFile>
    </ItemGroup>

    <ItemGroup>
        <!-- Create an item list for the trust licenses to be used in the ClickOnce deploy manifest -->
        <TrustLicenses Include="$(TrustLicenseFile)">
            <InProject>false</InProject>
        </TrustLicenses>

        <!-- Create an item for entry point of the ClickOnce application (Example: WindowsApplication1.exe) -->
        <ManifestEntryPoint Include="@(IntermediateAssembly)" Condition="'$(GenerateClickOnceManifests)'=='true'">
            <TargetPath>$(TargetFileName)</TargetPath>
            <InProject>false</InProject>
        </ManifestEntryPoint>

        <!-- Create an item for the application icon if one exists in the project (Example: app.ico) -->
        <ManifestIconFile Include="$(ApplicationIcon)" Condition="Exists('$(ApplicationIcon)')">
            <TargetPath>$(ApplicationIcon)</TargetPath>
            <InProject>false</InProject>
        </ManifestIconFile>

        <!-- Create an item for the output application manifest (Example: WindowsApplication1.exe.manifeset) -->
        <ApplicationManifest Include="$(IntermediateOutputPath)$(TargetApplicationManifestFileName)">
            <TargetPath>$(TargetApplicationManifestFileName)</TargetPath>
            <InProject>false</InProject>
        </ApplicationManifest>

        <!-- Create an item for the output deploy manifest (Example: WindowsApplication1.application) -->
        <DeployManifest Include="$(IntermediateOutputPath)$(TargetDeployManifestFileName)">
            <TargetPath>$(TargetDeployManifestFileName)</TargetPath>
            <InProject>false</InProject>
        </DeployManifest>
    </ItemGroup>

    <!--
    Determine the target URL for ClickOnce deployment.
    Prefer the UpdateUrl, falling back to InstallUrl or PublishUrl if blank
    -->
    <PropertyGroup>
        <TargetUrl>$(UpdateUrl)</TargetUrl>
        <TargetUrl Condition="'$(TargetUrl)'==''">$(InstallUrl)</TargetUrl>
        <TargetUrl Condition="'$(TargetUrl)'==''">$(PublishUrl)</TargetUrl>
        <TargetUrl Condition="'$(TargetUrl)'!=''">$(TargetUrl)/$(TargetDeployManifestFileName)</TargetUrl>
    </PropertyGroup>

    <!--
    Determine the URLs for the bootstrapper
    -->
    <PropertyGroup>
        <ApplicationUrl Condition="'$(IsWebBootstrapper)'=='true'">$(InstallUrl)</ApplicationUrl>
        <ApplicationUrl Condition="'$(IsWebBootstrapper)_$(InstallUrl)'=='true_'">$(PublishUrl)</ApplicationUrl>
        <ComponentsUrl Condition="'$(BootstrapperComponentsUrlEnabled)'=='true'">$(BootstrapperComponentsUrl)</ComponentsUrl>
    </PropertyGroup>

    <!--
    Output location for publish target.
    -->
    <PropertyGroup>
        <PublishDir Condition="'$(PublishDir)'==''">publish\</PublishDir>
    </PropertyGroup>

    <!--
    Determine the target OS version for ClickOnce deployment.
    If using regfree COM (i.e. one or more manifest references) then the minimum OS
    version is Windows XP RTM.
    However, this can be overriden if an explicit OSVersion is specified in the project.
    -->
    <PropertyGroup>
        <TargetOSVersion Condition="'@(NativeReference)'!=''">5.1.2600.0</TargetOSVersion>
        <TargetOSVersion Condition="'$(OSVersion)'!=''">$(OSVersion)</TargetOSVersion>
    </PropertyGroup>

    <!--
    Platform is the target Processor Architecture. For example, x86, IA64 or AMD64.
    -->
    <PropertyGroup>
        <ProcessorArchitecture Condition="'$(ProcessorArchitecture)'==''">x86</ProcessorArchitecture>
    </PropertyGroup>

    <!--
    AvailablePlatforms is the list of platform targets available.
    -->
    <PropertyGroup>
        <AvailablePlatforms>Any CPU,x86,x64,Itanium</AvailablePlatforms>
    </PropertyGroup>

    <!--
    The default for compilers is to not delay-sign. If $(DelaySign) is false, let the compiler
    use its default rather than forcing a no-delay-sign flag to be passed in. This is so that
    attributes in the source code can override this decision.
    -->
    <PropertyGroup>
        <DelaySign Condition="'$(DelaySign)'!='true'"></DelaySign>
    </PropertyGroup>

    <!--
    These properties control web reference proxy generation.
    -->
    <PropertyGroup>
        <WebReference_EnableProperties Condition=" '$(WebReference_EnableProperties)' == '' ">true</WebReference_EnableProperties>
        <WebReference_EnableSQLTypes Condition=" '$(WebReference_EnableSQLTypes)' == '' ">true</WebReference_EnableSQLTypes>
        <WebReference_EnableLegacyEventingModel Condition=" '$(WebReference_EnableLegacyEventingModel)' == '' ">false</WebReference_EnableLegacyEventingModel>
    </PropertyGroup>

    <!--
    Default set of FxCop rules.  Can be overridden in project file.
    -->
    <PropertyGroup>
        <FxCopRules Condition="'$(FxCopRules)'==''">ComRules.dll;DesignRules.dll;GlobalizationRules.dll;MaintainabilityRules.dll;NamingRules.dll;PerformanceRules.dll;ReliabilityRules.dll;SecurityRules.dll;UsageRules.dll</FxCopRules>
        <FxCopExclusionsFile Condition="'$(FxCopExclusionsFile)'==''">Exclusions.FxCop</FxCopExclusionsFile>
    </PropertyGroup>

    <PropertyGroup>
        <MSBuildAllProjects>$(MSBuildProjectFullPath);$(MSBuildBinPath)\Microsoft.Common.targets</MSBuildAllProjects>
        <MSBuildAllProjects Condition="Exists('$(MSBuildProjectFullPath).user')">$(MSBuildAllProjects);$(MSBuildProjectFullPath).user</MSBuildAllProjects>
    </PropertyGroup>

    <!--
    These parameters control where to look in the registry for directories to search for
    assemblies in the assembly resolution tasks.
    -->
    <PropertyGroup>
        <FrameworkRegistryBase Condition=" '$(FrameworkRegistryBase)' == '' ">Software\Microsoft\.NetFramework</FrameworkRegistryBase>
        <TargetFrameworkVersion Condition=" '$(TargetFrameworkVersion)' == '' ">v2.0</TargetFrameworkVersion>
        <AssemblyFoldersSuffix Condition=" '$(AssemblyFoldersSuffix)' == '' ">AssemblyFoldersEx</AssemblyFoldersSuffix>
    </PropertyGroup>

    <!--
    The SearchPaths property is set to find assemblies in the following order:

        (1) Files from current project - indicated by {CandidateAssemblyFiles}
        (2) $(ReferencePath) - the reference path property, which comes from the .USER file.
        (3) The directory of MSBuild's "target" runtime from GetFrameworkPath.
             The "target" runtime folder is the folder of the runtime that MSBuild is a part of.
        (4) Registered assembly folders, indicated by {Registry:*,*,*}
        (5) Legacy registered assembly folders, indicated by {AssemblyFolders}
        (6) $(HintPath) - the hintpath from the referenced item itself, indicated by {HintPath}.
        (7) Resolve to the GAC.
        (8) Treat the reference's Include as if it were a real file name.
    -->
    <PropertyGroup>
        <AssemblySearchPaths Condition=" '$(AssemblySearchPaths)' == '' ">
            {CandidateAssemblyFiles};
            $(ReferencePath);
            {HintPathFromItem};
            {TargetFrameworkDirectory};
            {Registry:$(FrameworkRegistryBase),$(TargetFrameworkVersion),$(AssemblyFoldersSuffix)};
            {AssemblyFolders};
            {GAC};
            {RawFileName}
        </AssemblySearchPaths>
    </PropertyGroup>

    <PropertyGroup>
        <BuildDependsOn>
            CoreBuild;
            CoreBuildSucceeded
        </BuildDependsOn>
    </PropertyGroup>
    <Target
        Name="Build"
        Outputs="$(TargetPath)"
        DependsOnTargets="$(BuildDependsOn)"
        />

    <!--
    This target creates <TargetPath> tags for items. <TargetPath> is a relative folder plus filename
    for the destination of this item.
    -->
    <Target
        Name="AssignTargetPaths"
        >

        <AssignTargetPath Files="@(EmbeddedResource)" RootFolder="$(MSBuildProjectDirectory)">
            <Output TaskParameter="AssignedFiles" ItemName="EmbeddedResourceWithTargetPath" />
        </AssignTargetPath>
        
        <AssignTargetPath Files="@(EmbeddedMappingSchemaFile)" RootFolder="$(MSBuildProjectDirectory)">
            <Output TaskParameter="AssignedFiles" ItemName="EmbeddedMappingSchemaFileWithTargetPath" />
        </AssignTargetPath>		
        
        <AssignTargetPath Files="@(Content)" RootFolder="$(MSBuildProjectDirectory)">
            <Output TaskParameter="AssignedFiles" ItemName="ContentWithTargetPath" />
        </AssignTargetPath>

        <AssignTargetPath Files="@(Compile)" RootFolder="$(MSBuildProjectDirectory)">
            <Output TaskParameter="AssignedFiles" ItemName="CompileWithTargetPath" />
        </AssignTargetPath>

        <AssignTargetPath Files="@(None)" RootFolder="$(MSBuildProjectDirectory)">
            <Output TaskParameter="AssignedFiles" ItemName="NoneWithTargetPath" />
        </AssignTargetPath>

        <CreateItem
            Include="@(None);@(Content)"
            Condition="'%(Filename)%(Extension)' == 'App.Config'"
            AddAttributeName="TargetPath"
            AddAttributeValue="$(TargetFileName).config"
            >
            <Output TaskParameter="Include" ItemName="AppConfigWithTargetPath" />
        </CreateItem>

        <AssignTargetPath
            Files="@(None)"
            RootFolder="$(MSBuildProjectDirectory)"
            Condition="'%(Extension)' == '.manifest'"
            >
            <Output TaskParameter="AssignedFiles" ItemName="BaseManifestWithTargetPath" />
        </AssignTargetPath>   
        
        <CreateProperty
            Value="$(TargetDir)">
            <Output TaskParameter="Value" PropertyName="TargetDir" />
        </CreateProperty>
        
        <CreateProperty
            Value="$(TargetPath)">
            <Output TaskParameter="Value" PropertyName="TargetPath" />
        </CreateProperty>        
        
    </Target>    

    <!--
    This target is called only when doing a real build or checking whether a build is required.
    It is specifically not called during project load.
    -->
    <PropertyGroup>
        <BuildOnlySettings></BuildOnlySettings>
        <BuildingProject>false</BuildingProject>
    </PropertyGroup>
    <Target
        Name="BuildOnlySettings">

        <CreateProperty Value="true">
            <Output TaskParameter="Value" PropertyName="BuildingProject" />
        </CreateProperty>

    </Target>

    <!--
    Prepare the prerequisites for building.
    -->
    <PropertyGroup>
        <PrepareForBuildDependsOn>GetFrameworkPaths;AssignTargetPaths</PrepareForBuildDependsOn>
    </PropertyGroup>
    <Target
        Name="PrepareForBuild"
        DependsOnTargets="$(PrepareForBuildDependsOn)"
        >

        <!-- Create the directories for intermediate and final build products. -->
        <MakeDir
              Directories="$(OutDir);$(IntermediateOutputPath);@(DocFileItem->'%(RelativeDir)')"/>

        <!--
        We support building libraries even when there are no source files.
        If no source file is specified in the project file, then we generate
        an empty one here with an extension of $(DefaultLanguageSourceExtension).
        -->
        <Touch
              Condition="'@(Compile)'==''"
              AlwaysCreate="true"
              Files="$(IntermediateOutputPath)VisualStudio.Empty$(DefaultLanguageSourceExtension)">

            <Output TaskParameter="TouchedFiles" ItemName="Compile" Condition=" '$(BuildingInsideVisualStudio)' != 'true' "/>
        </Touch>


    </Target>

    <!--
    Get the Frameworks and Platform SDK paths.
    -->
    <PropertyGroup>
        <GetFrameworkPathsDependsOn></GetFrameworkPathsDependsOn>
    </PropertyGroup>
    <Target
        Name="GetFrameworkPaths"
        DependsOnTargets="$(GetFrameworkPathsDependsOn)"
        >

        <!-- Get the path to the target .NET framework directory. -->
        <GetFrameworkPath>
            <Output TaskParameter="Path" PropertyName="TargetFrameworkDirectory"/>
        </GetFrameworkPath>

        <!-- Get the path to the target .NET framework SDK directory. -->
        <GetFrameworkSDKPath>
            <Output TaskParameter="Path" PropertyName="TargetFrameworkSDKDirectory"/>
        </GetFrameworkSDKPath>

    </Target>

    <!--
    Run the pre-build event if there is one.
    -->
    <PropertyGroup>
        <PreBuildEventDependsOn></PreBuildEventDependsOn>
    </PropertyGroup>
    <Target
        Name="PreBuildEvent"
        Condition="'$(PreBuildEvent)'!=''"
        DependsOnTargets="$(PreBuildEventDependsOn)"
        >

        <Exec
              WorkingDirectory="$(OutDir)"
              Command="$(PreBuildEvent)" />

    </Target>

    <PropertyGroup>
        <UnmanagedUnregistrationDependsOn></UnmanagedUnregistrationDependsOn>
    </PropertyGroup>
    <Target
        Name="UnmanagedUnregistration"
        Condition="'$(RegisterForComInterop)_and_$(OutputType)'=='true_and_library'"
        DependsOnTargets="$(UnmanagedUnregistrationDependsOn)"
        >

        <UnregisterAssembly
            Condition="Exists('$(OutputPath)$(TargetFileName)')"
            Assemblies="$(OutputPath)$(TargetFileName)"
        />

    </Target>

    <!--
    Determine the strong name key source.
        [IN]
        $(AssemblyKeyContainerName)   - The key file
        $(AssemblyOriginatorKeyFile)  - The key file type (.snk or .pfx)

        [OUT]
        $(KeyContainerName)  - Use a container
        $(KeyOriginatorFile) - Use a file contining the key definition (.snk).
    -->
    <Target
        Name="ResolveKeySource"
        Condition="'$(AssemblyKeyContainerName)$(AssemblyOriginatorKeyFile)'!=''"
        >

        <ResolveKeySource
              KeyContainer="$(AssemblyKeyContainerName)"
              KeyFile="$(AssemblyOriginatorKeyFile)"
              SuppressAutoClosePasswordPrompt="$(BuildingInsideVisualStudio)"
              >

            <Output TaskParameter="ResolvedKeyContainer" PropertyName="ManifestKeyContainerName"/>
            <Output TaskParameter="ResolvedKeyFile" PropertyName="ManifestKeyOriginatorFile"/>
        </ResolveKeySource>

        <CreateProperty
            Value="$(ManifestKeyContainerName)"
            Condition=" '$(SignAssembly)' == 'true' ">

            <Output TaskParameter="Value" PropertyName="KeyContainerName" />
        </CreateProperty>

        <CreateProperty
            Value="$(ManifestKeyOriginatorFile)"
            Condition=" '$(SignAssembly)' == 'true' ">

            <Output TaskParameter="Value" PropertyName="KeyOriginatorFile" />
        </CreateProperty>

        <CreateProperty
            Value="$(AssemblyKeyProviderName)" >

            <Output TaskParameter="Value" PropertyName="KeyProviderName" />
        </CreateProperty>


        <Message Text="(out) KeySources: Container:'$(KeyContainerName)' File:'$(KeyOriginatorFile)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(out) KeySources: ManifestContainer:'$(ManifestKeyContainerName)' ManifestFile:'$(ManifestKeyOriginatorFile)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

    </Target>


    <!--
    Resolve native references

        [IN]
        @(NativeReference) - The manifest reference (or list of manifest references)

        [OUT]
        @(NativeReferenceFile)  - List of manifest files referenced.
        @(NetAssemblyReference) - List of .NET assemblies contained in the manifest.
        @(COMComponents)        - List of COM components contained in the manifest.
        @(TypeLibraries)        - List of type libraries contained in the manifest.
        @(COMFileReference)     - List of loose files contained in the manifest.
        @(LooseManifestFile)    - List of loose files contained in the manifest.
    -->
    <Target
        Name="ResolveNativeReferences"
        Condition="'@(NativeReference)'!=''"
        >

        <Message Text="(in) Native References: '@(NativeReference)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

        <ResolveNativeReference
              NativeReferences="@(NativeReference)"
              >

            <Output TaskParameter="ContainingReferenceFiles" ItemName="NativeReferenceFile"/>
            <Output TaskParameter="ContainedNetAssemblies" ItemName="NetAssemblyReference"/>
            <Output TaskParameter="ContainedComComponents" ItemName="ComClassReference"/>
            <Output TaskParameter="ContainedTypeLibraries" ItemName="COMReference"/>
            <Output TaskParameter="ContainedLooseTlbFiles" ItemName="COMFileReference"/>
            <Output TaskParameter="ContainedLooseEtcFiles" ItemName="LooseManifestFile"/>

        </ResolveNativeReference>

        <Message Text="(out) NativeReferenceFile: '@(NativeReferenceFile)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(out) NetAssemblyReference: '@(NetAssemblyReference)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(out) ComClassReference: '@(ComClassReference)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(out) COMReference: '@(COMReference)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(out) COMFileReference: '@(COMFileReference)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(out) LooseManifestFile: '@(LooseManifestFile)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

    </Target>

    <!--
    Resolve COM references

        [IN]
        @(COMReference) - The list of COM references
        $(BaseOutputPath) - The output directory in which to generate wrapper assemblies

        [OUT]
        @(ReferencePath) - Paths to referenced wrappers.

        NOTE: If ResolveComReferences is invoked from the IDE, PrepareForBuild may need to run to create directories,
                so don't remove the PrepareForBuild target from the DependsOnTargets below!
    -->
    <Target
        Name="ResolveComReferences"
        Condition="'@(COMReference)_@(COMFileReference)'!='_'"
        DependsOnTargets="PrepareForBuild;ResolveKeySource;ResolveAssemblyReferences"
        >

        <Message Text="(in) COM References: '@(COMReference)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) COM File References: '@(COMFileReference)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>


        <ResolveComReference
              TypeLibNames="@(COMReference)"
              TypeLibFiles="@(COMFileReference)"
              ResolvedAssemblyReferences="@(ReferencePath)"
              WrapperOutputDirectory="$(BaseOutputPath)"
              KeyContainer="$(KeyContainerName)"
              KeyFile="$(KeyOriginatorFile)"
              DelaySign="$(DelaySign)"
              >

            <Output TaskParameter="ResolvedFiles" ItemName="ReferencePath"/>

            <Output TaskParameter="ResolvedFiles" ItemName="ReferenceComWrappersToCopyLocal"/>

            <Output TaskParameter="ResolvedModules" ItemName="ResolvedIsolatedComModules"
                Condition=" '%(COMReference.Isolated)' == 'true' "/>

        </ResolveComReference>

        <Message Text="(out) ResolvedReferencePaths: '@(ReferencePath)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
    </Target>

    <!--
    Split project references into two lists: VC project references and others (handled by the MSBuild engine)

        [IN]
        @(ProjectReference) - the list of all project references

        [OUT]
        @(VCProjectReference) - the list of VC (managed VC++ to be exact) project references
        @(MSBuildProjectReference) - the list of MSBuild project references
    -->
    <Target
        Name="SplitProjectReferencesByType"
        Condition="'@(ProjectReference)'!=''">

        <Message Text="(in) All Project References: '@(ProjectReference)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

        <!-- Copy all VC project references to the VCProjectReference item list (using the VC package GUID) -->
        <CreateItem
            Include="@(ProjectReference)"
            Condition="'%(ProjectReference.Package)'=='{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}'">

            <Output TaskParameter="Include" ItemName="VCProjectReference"/>
        </CreateItem>

        <!-- Copy the rest of the project references to the MSBuildProjectReference item list -->
        <CreateItem
            Include="@(ProjectReference)"
            Condition="'%(ProjectReference.Package)'!='{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}'">

            <Output TaskParameter="Include" ItemName="MSBuildProjectReference"/>
        </CreateItem>

        <Message Text="(out) VC Project References: '@(VCProjectReference)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(out) MSBuild Project References: '@(MSBuildProjectReference)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
    </Target>

    <!--
    Find outputs of referenced VC projects (currently we never build VC projects ourselves)

        [IN]
        @(VCProjectReference) - the list of VC project references

        [OUT]
        @(ResolvedProjectReferencePaths) - paths to projects' outputs
    -->

    <!--
    This is a simplified way to guess the configuration we should look up in the VC project.
    This will go away once we implement solution configurations properly
    -->
    <PropertyGroup Condition="'$(BuildingInsideVisualStudio)'!='true'">
        <VCConfiguration>$(Configuration)|Win32</VCConfiguration>
    </PropertyGroup>
    <Target
        Name="ResolveVCProjectReferences"
        Condition="'@(VCProjectReference)'!=''"
        DependsOnTargets="SplitProjectReferencesByType">

        <Message Text="(in) VC Project References: '@(VCProjectReference)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

        <!-- This property is prepopulated with VC project outputs by VS if we're building inside the IDE -->
        <Message Text="(in) Resolved VC References: '$(ResolvedVCProjectOutputs)'" Condition="'$(MSBuildTargetsVerbose)$(BuildingInsideVisualStudio)'=='truetrue'"/>

        <ResolveVCProjectOutput
            ProjectReferences="@(VCProjectReference)"
            PreresolvedVCOutputs="$(ResolvedVCProjectOutputs)"
            Condition="'$(BuildingInsideVisualStudio)'=='true'">

            <Output TaskParameter="ResolvedOutputPaths" ItemName="ResolvedProjectReferencePaths"/>

        </ResolveVCProjectOutput>

        <ResolveVCProjectOutput
            ProjectReferences="@(VCProjectReference)"
            Configuration="$(VCConfiguration)"
            Condition="'$(BuildingInsideVisualStudio)'!='true'">

            <Output TaskParameter="ResolvedOutputPaths" ItemName="ResolvedProjectReferencePaths"/>

        </ResolveVCProjectOutput>

        <Message Text="(out) ReferencePaths: '@(ResolvedProjectReferencePaths)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

    </Target>

    <!--
    Build referenced projects:

        [IN]
        @(MSBuildProjectReference) - The list of project references.

        [OUT]
        @(ResolvedProjectReferencePaths) - Paths to referenced projects.
    -->
    <Target
        Name="ResolveProjectReferences"
        Condition="'@(MSBuildProjectReference)'!=''"
        DependsOnTargets="SplitProjectReferencesByType">

        <Message Text="(in) MSBuild Project References: '@(MSBuildProjectReference)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

        <!--
        Build referenced projects when doing an integrated build from VisualStudio.
        When building from VisualStudio, just gather the referenced build outputs.
        Visual studio will already have built the project, so there's no need to
        do it again here.

        We have ContinueOnError="true" because we don't want to block the build if
        one of the referenced projects doesn't exist or contains syntax errors.
        -->
        <MSBuild
              Projects="@(MSBuildProjectReference)"
              Targets="MainBuiltProjectOutputGroup"
              Condition="'$(BuildingInsideVisualStudio)'=='true'"
              ContinueOnError="!$(BuildingProject)">

             <Output TaskParameter="TargetOutputs" ItemName="ResolvedProjectReferencePaths"/>

        </MSBuild>

        <!--
        Build referenced projects when building from the command line.
        When building from the command line, always build the referenced projects.
        -->
        <MSBuild
              Projects="@(MSBuildProjectReference)"
              Condition="'$(BuildingInsideVisualStudio)'!='true'">

             <Output TaskParameter="TargetOutputs" ItemName="ResolvedProjectReferencePaths"/>

        </MSBuild>

        <Message Text="(out) ReferencePaths: '@(ResolvedProjectReferencePaths)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

    </Target>

    <!--
    Split EmbeddedResource and EmbeddedMappingSchemaFile into five lists based on whether
    they are resx files, licx files or other resources and whether they should be localized.

        [IN]
        @(EmbeddedResourceWithTargetPath) - The raw list of resources.
        @(EmbeddedMappingSchemaFileWithTargetPath) - The raw list of embedded mapping schema file resources.

        [INTERMEDIATES]
        @(MixedResourceWithNoCulture) - The EmbeddedResource items that have no Culture property.
        @(MixedResourceWithCulture) - The EmbeddedResource items that have a Culture property.

        [OUT]
        @(LicxFile) - The EmbeddedResource items with extension equal to '.licx'.
        @(ResxWithNoCulture) - Those with no culture that should be passed through the ResGen task.
        @(ResxWithCulture) - Those with culture that should be passed through the ResGen task.
        @(NonResxWithNoCulture) - Those that should be passed directly into the compiler.
        @(NonResxWithCulture) - Those that should be passed directly into AL for the satellite assemblies.
    -->
    <Target
        Name="SplitResourcesByCulture"
        DependsOnTargets="AssignTargetPaths"
        >

        <Message Text="(in) Resources: '@(EmbeddedResourceWithTargetPath)@(EmbeddedMappingSchemaFileWithTargetPath)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

        <CreateItem
            Condition="'%(Extension)'=='.licx'"
            Include="@(EmbeddedResourceWithTargetPath)">

            <Output TaskParameter="Include" ItemName="LicxFile"/>
        </CreateItem>

        <Message Text="(out) LicxFile: '@(LicxFile)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

        <AssignCulture
              Condition="'%(Extension)'!='.licx'"
              Files="@(EmbeddedResourceWithTargetPath);@(EmbeddedMappingSchemaFileWithTargetPath)">

            <!-- Create the list of culture resx and embedded resource files -->
            <Output TaskParameter="AssignedFilesWithCulture" ItemName="MixedResourceWithCulture"/>
            <!-- Create the list of non-culture resx and embedded resource files -->
            <Output TaskParameter="AssignedFilesWithNoCulture" ItemName="MixedResourceWithNoCulture"/>
        </AssignCulture>


        <Message Text="(intermediate) EmbeddedResource files with no culture: '@(MixedResourceWithNoCulture)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(intermediate) EmbeddedResource files with culture: '@(MixedResourceWithCulture)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

        <CreateItem
              Condition="'%(Extension)'=='.resx'"
              Include="@(MixedResourceWithNoCulture)">

            <Output TaskParameter="Include" ItemName="ResxWithNoCulture"/>
        </CreateItem>
        <CreateItem
              Condition="'%(Extension)'!='.resx'"
              Include="@(MixedResourceWithNoCulture)">
            <Output TaskParameter="Include" ItemName="NonResxWithNoCulture"/>
        </CreateItem>

        <Message Text="(out) Non *.resx files with no culture: '@(NonResxWithNoCulture)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(out) Resx files with no culture: '@(ResxWithNoCulture)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

        <CreateItem
              Condition="'%(Extension)'=='.resx'"
              Include="@(MixedResourceWithCulture)">

            <Output TaskParameter="Include" ItemName="ResxWithCulture"/>
        </CreateItem>
        <CreateItem
              Condition="'%(Extension)'!='.resx'"
              Include="@(MixedResourceWithCulture)">

            <Output TaskParameter="Include" ItemName="NonResxWithCulture"/>
        </CreateItem>

        <Message Text="(out) Non *.resx files with culture: '@(NonResxWithCulture)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(out) Resx files with culture: '@(ResxWithCulture)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

    </Target>

    <!--
    Copy non-resx resource files from their original name to the manifest resource name.
    This is so that the file will be in the location expected by the compiler.

    UNDONE-RG.  This target should go away entirely.  We shouldn't need to copy the non-RESXs
    to their manifest name.  Instead, just stick a "LogicalName" attribute on it, and it should
    be taken care of by the compiler automatically.

        [IN]
        @(NonResxWithNoCulture) - The list of non-culture non-resx resource files to copy.
        @(NonResxWithCulture) - The list of culture non-resx resource files to copy.
        @(ManifestNonResxWithNoCulture) - The manifest resource name of non-culture non-resx resource files.
        @(ManifestNonResxWithCulture) - The manifest resource name of culture non-resx resource files.

        [OUT]
        @(ManifestNonResxWithNoCultureOnDisk) - The final location on disk of the non-culture non-resx resource files.
        @(ManifestNonResxWithCultureOnDisk) - The final location on disk of the culture non-resx resource files.
    -->
    <Target
        Name="CopyNonResxEmbeddedResources"
        Condition="'@(NonResxWithNoCulture)@(NonResxWithCulture)@(ManifestNonResxWithNoCulture)@(ManifestNonResxWithCulture)'!=''"
        >

        <Message Text="(in) The names of the non-RESX files to copy from: '@(NonResxWithNoCulture);@(NonResxWithCulture)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) Manifest-named non *.resx files to copy to: '@(ManifestNonResxWithNoCulture);@(ManifestNonResxWithCulture)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

        <Copy
            SourceFiles="@(NonResxWithNoCulture)"
            DestinationFiles="@(ManifestNonResxWithNoCulture->'$(IntermediateOutputPath)%(Identity)')"
            SkipUnchangedFiles="true"
            Condition="'@(NonResxWithNoCulture)'!=''"
            >

            <Output
                TaskParameter="DestinationFiles"
                ItemName="ManifestNonResxWithNoCultureOnDisk"/>

        </Copy>

        <MakeDir
            Directories="$(IntermediateOutputPath)%(ManifestNonResxWithCulture.Culture)"
            />

        <Copy
            SourceFiles="@(NonResxWithCulture)"
            DestinationFiles="@(ManifestNonResxWithCulture->'$(IntermediateOutputPath)%(Identity)')"
            SkipUnchangedFiles="true"
            Condition="'@(NonResxWithCulture)'!=''"
            >

            <Output
                TaskParameter="DestinationFiles"
                ItemName="ManifestNonResxWithCultureOnDisk"/>

        </Copy>

    </Target>

    <!--
    Run resgen on the given resx files.

    This task checks timestamps internally for the .resx files as well as any linked files that are
    referenced in the .resx file against the .resources file, so it does not need to specify Inputs
    or Outputs in the Target.

        [IN]
        @(ResxWithNoCulture) - The names the non-culture .RESX files.
        @(ResxWithCulture) - The names the culture .RESX files.
        @(ManifestResourceWithNoCultureName) - The corresponding manifest resource name (.RESOURCE)
        @(ManifestResourceWithCultureName) - The corresponding manifest resource name (.RESOURCE)

        [OUT]
        @(ManifestResourceWithNoCulture) - The path to the corresponding .RESOURCE  files
        @(ManifestResourceWithCulture) - The path to the corresponding .RESOURCE  files
    -->
    <PropertyGroup>
        <ResGenDependsOn>ResolveAssemblyReferences</ResGenDependsOn>
        <UseSourcePath Condition="'$(UseSourcePath)'==''">true</UseSourcePath>
    </PropertyGroup>
    <Target
        Name="ResGen"
        Condition="'@(ResxWithNoCulture)@(ResxWithCulture)'!=''"
        DependsOnTargets="$(ResGenDependsOn)"
        >

        <Message Text="(in) The names the non-culture .RESX files: '@(ResxWithNoCulture)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) The names the culture .RESX files: '@(ResxWithCulture)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) Manifest-named resx files files with no culture: '@(ManifestResourceWithNoCultureName)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) Manifest-named resx files with culture: '@(ManifestResourceWithCultureName)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

        <ResGen
            Sources="@(ResxWithNoCulture)"
            Condition=" '@(ResxWithNoCulture)' != '' "
            References="@(ReferencePath)"
            UseSourcePath="$(UseSourcePath)"
            StateFile="$(IntermediateOutputPath)ResGen.cache"
            OutputResources="@(ManifestResourceWithNoCultureName->'$(IntermediateOutputPath)%(Identity).resources')"
            ToolPath="$(ResGenToolPath)">

            <Output
                TaskParameter="OutputResources"
                ItemName="ManifestResourceWithNoCulture"/>
        </ResGen>

        <ResGen
            Sources="@(ResxWithCulture)"
            Condition=" '@(ResxWithCulture)' != '' "
            References="@(ReferencePath)"
            UseSourcePath="$(UseSourcePath)"
            OutputResources="@(ManifestResourceWithCultureName->'$(IntermediateOutputPath)%(Identity).resources')"
            ToolPath="$(ResGenToolPath)">

            <Output
                TaskParameter="OutputResources"
                ItemName="ManifestResourceWithCulture"/>
        </ResGen>

        <Message Text="(out) The path to the corresponding non-culture .RESOURCE files: '@(ManifestResourceWithNoCulture)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(out) The path to the corresponding culture .RESOURCE  files: '@(ManifestResourceWithCulture)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

    </Target>

    <!--
    Create one satellite assembly for every unique culture in the resources.

        [IN]
        @(ManifestResourceWithCulture) - The list of culture-specific resource (.RESOURCE) files.
        @(ManifestNonResxWithCultureOnDisk) - The list of culture-specific non-.RESX resource files.

        [OUT]
        @(SatelliteAssemblies) - Those with no culture that should be passed through the ResGen task.
    -->
    <PropertyGroup>
        <CreateSatelliteAssembliesDependsOn></CreateSatelliteAssembliesDependsOn>
    </PropertyGroup>
    <Target
        Name="CreateSatelliteAssemblies"
        Condition="'@(ManifestResourceWithCulture)@(ManifestNonResxWithCultureOnDisk)'!=''"
        Inputs="@(ManifestResourceWithCulture);@(ManifestNonResxWithCultureOnDisk);@(IntermediateAssembly)"
        Outputs="$(IntermediateOutputPath)%(Culture)\$(TargetName).resources.dll"
        DependsOnTargets="$(CreateSatelliteAssembliesDependsOn)"
     >
        <Message Text="(in) The list of locale-specific resource files: '@(ManifestResourceWithCulture);@(ManifestNonResxWithCultureOnDisk)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

        <MakeDir
            Directories="$(IntermediateOutputPath)%(ManifestResourceWithCulture.Culture)"
            Condition=" '@(ManifestResourceWithCulture)' != '' "
            />

        <MakeDir
            Directories="$(IntermediateOutputPath)%(ManifestNonResxWithCultureOnDisk.Culture)"
            Condition=" '@(ManifestNonResxWithCultureOnDisk)' != '' "
            />

        <AL
            EmbedResources="@(ManifestResourceWithCulture);@(ManifestNonResxWithCultureOnDisk)"
            Culture="%(Culture)"
            TemplateFile="@(IntermediateAssembly)"
            KeyContainer="$(KeyContainerName)"
            KeyFile="$(KeyOriginatorFile)"
            DelaySign="$(DelaySign)"
            OutputAssembly="$(IntermediateOutputPath)%(Culture)\$(TargetName).resources.dll">

            <Output TaskParameter="OutputAssembly"
                    ItemName="SatelliteAssemblies"/>
        </AL>

        <Message Text="(out) The list of satellite assemblies: '@(SatelliteAssemblies)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
    </Target>

    <!--
    Given the list of assemblies, find the closure of all assemblies that they depend on. These are
    what we need to copy to the output directory.

        [IN]
        @(Reference) - List of assembly references as fusion names.
        @(NetAssemblyReference) - List of assembly references from manifests.
        @(ResolvedProjectReferencePaths) - List of project references produced by projects that this project depends on.

            The 'Private' attribute on the reference corresponds to corresponds to the Copy Local flag in VS.
            The 'Private' flag can have three possible values:
                - 'True' means the reference should be Copied Local
                - 'False' means the reference should not be Copied Local
                - [Missing] means this task will decide whether to treat this reference as CopyLocal or not.

        [OUT]
        @(ReferencePath) - Paths to resolved primary files.
        @(ReferenceDependencyPaths) - Paths to resolved dependency files.
        @(ReferenceRelatedPaths) - Paths to .xmls and .pdbs.
        @(ReferenceSatellitePaths) - Paths to satellites.
        @(ReferenceCopyLocalPaths) - Paths to files that should be copied to the local directory.
    -->
    <PropertyGroup>
        <ResolveAssemblyReferencesDependsOn>GetFrameworkPaths;AssignTargetPaths</ResolveAssemblyReferencesDependsOn>
    </PropertyGroup>
    <Target
        Name="ResolveAssemblyReferences"
        Condition="'@(Reference)@(NetAssemblyReference)@(ResolvedProjectReferencePaths)'!=''"
        DependsOnTargets="$(ResolveAssemblyReferencesDependsOn)"
     >
        <Message Text="(in) The list of all assembly references: '@(Reference);@(NetAssemblyReference)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) The list of all project references: '@(ResolvedProjectReferencePaths)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) Candidate assembly files from Content and None groups: '@(Content);@(None)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) Search paths: $(AssemblySearchPaths)" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

        <!--
        Only read and write cache file at build time, skip it for load time because its more
        expensive to write the newly created cache file.
        -->
        <CreateProperty
            Value="$(IntermediateOutputPath)ResolveAssemblyReference.cache"
            Condition="'$(BuildingProject)'=='true'">

            <Output TaskParameter="Value" PropertyName="ResolveAssemblyReferencesStateFile" />

        </CreateProperty>

        <!--
        Make an App.Config item that exists when AutoUnify is false.
        -->
        <CreateItem
            Include="@(AppConfigWithTargetPath)"
            Condition="'$(AutoUnifyAssemblyReferences)'=='false'">
            <Output TaskParameter="Include" ItemName="ApplicationConfigFileForExes" />
        </CreateItem>

        <ResolveAssemblyReference
            Assemblies="@(Reference);@(NetAssemblyReference)"
            AssemblyFiles="@(ResolvedProjectReferencePaths)"
            TargetFrameworkDirectory="$(TargetFrameworkDirectory)"
            CandidateAssemblyFiles="@(Content);@(None)"
            SearchPaths="$(AssemblySearchPaths)"
            TargetProcessorArchitecture="$(ProcessorArchitecture)"
            AppConfigFile="@(ApplicationConfigFileForExes)"
            AutoUnify="$(AutoUnifyAssemblyReferences)"
            FindDependencies="$(BuildingProject)"
            FindSatellites="$(BuildingProject)"
            FindRelatedFiles="$(BuildingProject)"
            Silent="!$(BuildingProject)"
            StateFile="$(ResolveAssemblyReferencesStateFile)"
            >

            <Output TaskParameter="ResolvedFiles" ItemName="ReferencePath"/>
            <Output TaskParameter="ResolvedDependencyFiles" ItemName="ReferenceDependencyPaths"/>
            <Output TaskParameter="RelatedFiles" ItemName="ReferenceRelatedPaths"/>
            <Output TaskParameter="SatelliteFiles" ItemName="ReferenceSatellitePaths"/>
            <Output TaskParameter="CopyLocalFiles" ItemName="ReferenceCopyLocalPaths"/>
            <Output TaskParameter="SuggestedRedirects" ItemName="SuggestedBindingRedirects"/>

        </ResolveAssemblyReference>


        <Message Text="(out) Resolved paths to primary references: '@(ReferencePath)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(out) Files to be copied to the output directory: '@(ReferenceCopyLocalPaths)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

    </Target>

    <PropertyGroup>
        <ResolveReferencesDependsOn>
            ResolveNativeReferences;
            SplitProjectReferencesByType;
            ResolveProjectReferences;
            ResolveVCProjectReferences;
            ResolveAssemblyReferences;
            ResolveComReferences
        </ResolveReferencesDependsOn>
    </PropertyGroup>
    <Target
        Name="ResolveReferences"
        DependsOnTargets="$(ResolveReferencesDependsOn)"/>

    <!--
    Compile .licx files (containing information about licensed controls used by the application) into .licenses files.

        [IN]
        @(LicxFile) - The list of .licx files in the project (usually there will be just one)

        [OUT]
        @(CompiledLicenseFile) - The list of compiled .licenses files (there will be just one)
    -->
    <PropertyGroup>
        <CompileLicxFilesDependsOn></CompileLicxFilesDependsOn>
    </PropertyGroup>
    <Target
        Name="CompileLicxFiles"
        Inputs="@(LicxFile);@(ReferencePath);@(ReferenceDependencyPaths)"
        Outputs="$(IntermediateOutputPath)$(TargetFileName).licenses"
        Condition="'@(LicxFile)'!=''"
        DependsOnTargets="$(CompileLicxFilesDependsOn)">

        <Message Text="(in) The list of .licx files: '@(LicxFile)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

        <LC
            Sources="@(LicxFile)"
            LicenseTarget="$(TargetFileName)"
            OutputDirectory="$(IntermediateOutputPath)"
            OutputLicenses="$(IntermediateOutputPath)$(TargetFileName).licenses"
            ReferencedAssemblies="@(ReferencePath);@(ReferenceDependencyPaths)">

            <Output
                TaskParameter="OutputLicenses"
                ItemName="CompiledLicenseFile"/>
        </LC>

        <Message Text="(out) The list of .licenses files: '@(CompiledLicenseFile)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

    </Target>


    <!--
    Determine whether any XML manifests should be generated.
    XML manifests are required if the application has any native or reg-free COM references,
    or if the ClickOnce option is enabled.
    The purpose of the set of three targets below is to cause the GenerateManifests target
        to run if any of the following conditions are met:
    a) If one or more NativeReference or ResolvedIsolatedComModules items are present.
    b) If GenerateClickOnceManifests property is true.
    -->
    <Target
        Name="BuildNativeManifest"
        Condition="'@(NativeReference)@(ResolvedIsolatedComModules)'!=''"
        DependsOnTargets="GenerateManifests"/>
    <Target
        Name="BuildClickOnceManifests"
        Condition="'$(GenerateClickOnceManifests)'=='true'"
        DependsOnTargets="GenerateManifests"/>
    <Target
        Name="BuildManifests"
        DependsOnTargets="BuildNativeManifest;BuildClickOnceManifests"/>


    <!--
    Compute info for native manifest generation

        [IN]
        @(IntermediateAssembly) - Path to built assembly, used to obtain version for generated manifest.

        [OUT]
        $(ManifestVersion) - Version of generated manifest.
    -->
    <Target
        Name="ComputeNativeManifestInfo"
        Condition="'$(GenerateClickOnceManifests)'!='true'">

        <!-- Obtain manifest version from the built assembly -->
        <Message Text="(in) IntermediateAssembly: '@(IntermediateAssembly)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <GetAssemblyIdentity AssemblyFiles="@(IntermediateAssembly)">
            <Output TaskParameter="Assemblies" ItemName="IntermediateAssemblyIdentity"/>
        </GetAssemblyIdentity>
        <Message Text="(out) IntermediateAssemblyIdentity: '@(IntermediateAssemblyIdentity)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <CreateProperty Value="@(IntermediateAssemblyIdentity->'%(Version)')">
            <Output TaskParameter="Value" PropertyName="ManifestVersion"/>
        </CreateProperty>
        <Message Text="(out) ManifestVersion: '$(ManifestVersion)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

    </Target>


    <!--
    Compute info for  ClickOnce manifest generation

        [IN]
        $(ApplicationVersion) - Application version, can be either 1.0.0.0 or 1.0.0.*.
        $(ApplicationRevision) - Application revision, used if ApplicationVersion is 1.0.0.*.
        $(TargetCulture) - Determines the set of sattelites to include in the manifest.
        @(BaseManifestWithTargetPath) - The base app.manifest from project.
        @(ReferencePath) - List of project references.
        @(ReferenceDependencyPaths) - List of dependent project references.
        $(IntermediateOutputPath) - Used to obtain debug symbols and documentation files for project.
        @(ReferenceRelatedPaths) - Used to obtain debug symbols and documentation files for dependent projects.
        @(Content) - Content files to include in manifest.
        @(PublishFile) - List that determines whether corresponding items are flagged in the manifest with attributes such as group, optional, etc.
        @(AppConfigWithTargetPath) - App config file, if present.
        @(ManifestIconFile) - Icon file, if present.
        @(SatelliteAssemblies) - List of satellites for project.
        @(ReferenceSatellitePaths) - List of satellites for dependent projects.
        $(TargetUrl) - Deployment provider url for manifest, required for all installed applications.
        $(SupportUrl) - Support url for manifest.

        [OUT]
        @(ManifestDependencies) - List of assemblies to be expressed as dependencies in the manifest.
        @(ManifestEntryPoint) - Identifies the manifest that defines the entry point for the application.
        @(ManifestFiles) - List of files to be expressed in the manifest, including icon file and config file if present.
        @(ManifestPrerequisites) - List of assemblies to be expressed as prerequisites in the manifest.
        @(ManifestSatellites) - List of assemblies to be expressed as satellites in the manifest.
        $(ManifestVersion) - Version of generated manifest.
        $(FormattedTargetUrl) - Formatted version of corresponding input url.
        $(FormattedSupportUrl) - Formatted version of corresponding input url.
    -->
    <Target
        Name="ComputeClickOnceManifestInfo"
        Condition="'$(GenerateClickOnceManifests)'=='true'"
        DependsOnTargets="AssignTargetPaths"
        >

        <!-- Create list of items for manifest generation -->
        <Message Text="(in) BaseManifestWithTargetPath: '@(BaseManifestWithTargetPath)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) EntryPoint: '@(ManifestEntryPoint)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) ReferencePath: '@(ReferencePath)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) ReferenceDependencyPaths: '@(ReferenceDependencyPaths)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) Prerequisites: '@(ManifestPrerequisites)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) Satellites: '@(SatelliteAssemblies);@(ReferenceSatellitePaths)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) Files: '@(Content)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) ExtraFiles: '$(IntermediateOutputPath)$(TargetName).pdb;$(IntermediateOutputPath)$(TargetName).xml;@(ReferenceRelatedPaths)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) PublishFiles: '@(PublishFile)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) ManifestConfigFile: '@(AppConfigWithTargetPath)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) ManifestIconFile: '@(ManifestIconFile)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) TargetCulture: '$(TargetCulture)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <ResolveManifestFiles
            BaseManifest="@(BaseManifestWithTargetPath)"
            Dependencies="@(ReferencePath);@(ReferenceDependencyPaths)"
            EntryPoint="@(ManifestEntryPoint)"
            ExcludedPermissions="$(ExcludedPermissions)"
            ExtraFiles="$(IntermediateOutputPath)$(TargetName).pdb;$(IntermediateOutputPath)$(TargetName).xml;@(ReferenceRelatedPaths)"
            Files="@(ContentWithTargetPath);@(ManifestIconFile);@(AppConfigWithTargetPath)"
            PublishFiles="@(PublishFile)"
            Satellites="@(SatelliteAssemblies);@(ReferenceSatellitePaths)"
            TargetCulture="$(TargetCulture)"
            TargetZone="$(TargetZone)"
            TrustInfoFile="$(IntermediateOutputPath)TrustInfo.xml"
            >
            <Output TaskParameter="OutputDependencies" ItemName="ManifestDependencies"/>
            <Output TaskParameter="OutputFiles" ItemName="ManifestFiles"/>
            <Output TaskParameter="OutputPrerequisites" ItemName="ManifestPrerequisites"/>
            <Output TaskParameter="OutputSatellites" ItemName="ManifestSatellites"/>
            <Output TaskParameter="OutputTrustInfoFile" PropertyName="TrustInfoFile" Condition="'$(TargetZone)'!=''"/>
        </ResolveManifestFiles>
        <Message Text="(out) ManifestDependencies: '@(ManifestDependencies)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(out) ManifestFiles: '@(ManifestFiles)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(out) ManifestPrerequisites: '@(ManifestPrerequisites)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(out) ManifestSatellites: '@(ManifestSatellites)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(out) TrustInfoFile: '$(TrustInfoFile)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

        <!-- Obtain manifest version from ApplicationVersion and ApplicationRevision properties -->
        <Message Text="(in) ApplicationVersion: '$(ApplicationVersion)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) ApplicationRevision: '$(ApplicationRevision)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <FormatVersion
            Version="$(ApplicationVersion)"
            Revision="$(ApplicationRevision)"
            >
                <Output TaskParameter="OutputVersion" PropertyName="ManifestVersion"/>
        </FormatVersion>
        <Message Text="(out) ManifestVersion: '$(ManifestVersion)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

        <Message Text="(in) TargetUrl: '$(TargetUrl)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <FormatUrl
            InputUrl="$(TargetUrl)"
            >
                <Output TaskParameter="OutputUrl" PropertyName="FormattedTargetUrl"/>
        </FormatUrl>
        <Message Text="(out) FormattedTargetUrl: '$(FormattedTargetUrl)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

        <Message Text="(in) SupportUrl: '$(SupportUrl)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <FormatUrl
            InputUrl="$(SupportUrl)"
            >
            <Output TaskParameter="OutputUrl" PropertyName="FormattedSupportUrl"/>
        </FormatUrl>
        <Message Text="(out) FormattedSupportUrl: '$(FormattedSupportUrl)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

    </Target>


    <!--
    Generate manifests

        [IN]
        @(BaseManifestWithTargetPath) - The base app.manifest from project.
        @(ResolvedIsolatedComModules) - The list of COM references to be isolated as reg-free COM dependencies for native assembly loader.
        @(NativeReferenceFile) - The list of native assembly dependencies for native assembly loader.
        @(ManifestFiles) - The list of loose files (content, pdb, xml, etc.) for ClickOnce.
        @(ManifestDependencies) - The list of application dependencies (typically this is the set of assembly dependencies in bin\) for ClickOnce.
        @(ManifestPrerequisites) - The list of application prerequisistes (typically this is the set of assembly dependencies not in bin\) for ClickOnce.
        @(ManifestSatellites) - The list of satellite assemblies for ClickOnce.
        @(AppConfigWithTargetPath) - App config file, if present.
        @(ManifestIconFile) - Icon file, if present.

        [OUT]
        @(ApplicationManifest) - Generated native or ClickOnce application manifest, i.e. WindowsApplication1.exe.manifest
        @(DeployManifest) - Generated ClickOnce deployment manifest, i.e. WindowsApplication1.application
    -->
    <Target
        Name="GenerateManifests"
        DependsOnTargets="ComputeNativeManifestInfo;ComputeClickOnceManifestInfo">

        <Message Text="(in) ApplicationManifestIdentitity: '$(ApplicationManifestIdentitity)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) ApplicationManifest: '@(ApplicationManifest)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) BaseManifestWithTargetPath: '@(BaseManifestWithTargetPath)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) IsolatedComReferences: '@(ResolvedIsolatedComModules)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) NativeReferenceFile: '@(NativeReferenceFile)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) Files: '@(ManifestFiles)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) EntryPoint: '@(ManifestEntryPoint)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) Dependencies: '@(ManifestDependencies)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) Prerequisites: '@(ManifestPrerequisites)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) Satellites: '@(ManifestSatellites)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) ManifestConfigFile: '@(AppConfigWithTargetPath)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) ManifestIconFile: '@(ManifestIconFile)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <GenerateApplicationManifest
            AssemblyName="$(ApplicationManifestIdentitity)"
            AssemblyVersion="$(ManifestVersion)"
            ConfigFile="@(AppConfigWithTargetPath)"
            CertificateFile="$(CertificateFile)"
            CertificatePassword="$(CertificatePassword)"
            DelaySign="$(DelaySign)"
            Dependencies="@(ManifestDependencies)"
            Description="$(Description)"
            EntryPoint="@(ManifestEntryPoint)"
            FallbackCulture="$(FallbackCulture)"
            Files="@(ManifestFiles)"
            FXVersion="$(FXVersion)"
            IconFile="@(ManifestIconFile)"
            InputManifest="@(BaseManifestWithTargetPath)"
            IsolatedComReferences="@(ResolvedIsolatedComModules)"
            KeyContainer="$(ManifestKeyContainerName)"
            KeyFile="$(ManifestKeyOriginatorFile)"
            KeyProvider="$(KeyProviderName)"
            NativeReferences="@(NativeReferenceFile)"
            OutputManifest="@(ApplicationManifest)"
            OSVersion="$(TargetOSVersion)"
            Platform="$(PlatformTarget)"
            Prerequisites="@(ManifestPrerequisites)"
            Satellites="@(ManifestSatellites)"
            TargetCulture="$(TargetCulture)"
            TrustInfoFile="$(TrustInfoFile)"
            />
        <Message Text="(out) ApplicationManifest: '@(ApplicationManifest)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

        <Message Text="(in) DeployManifestIdentitity: '$(DeployManifestIdentitity)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) DeployManifest: '@(DeployManifest)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <GenerateDeploymentManifest
            Condition="'$(GenerateClickOnceManifests)'=='true'"
            AssemblyName="$(DeployManifestIdentitity)"
            AssemblyVersion="$(ManifestVersion)"
            CertificateFile="$(CertificateFile)"
            CertificatePassword="$(CertificatePassword)"
            DelaySign="$(DelaySign)"
            Description="$(Description)"
            EntryPoint="@(ApplicationManifest)"
            Install="$(Install)"
            KeyContainer="$(ManifestKeyContainerName)"
            KeyFile="$(ManifestKeyOriginatorFile)"
            KeyProvider="$(KeyProviderName)"
            OutputManifest="@(DeployManifest)"
            Platform="$(PlatformTarget)"
            Product="$(ProductName)"
            Publisher="$(PublisherName)"
            SupportUrl="$(FormattedSupportUrl)"
            TargetCulture="$(TargetCulture)"
            TargetUrl="$(FormattedTargetUrl)"
            TrustLicenses="@(TrustLicenses)"
            UpdateEnabled="$(UpdateEnabled)"
            UpdateInterval="$(UpdateInterval)"
            UpdateMode="$(UpdateMode)"
            UpdatePeriodically="$(UpdatePeriodically)"
            UpdateRequired="$(UpdateRequired)"
            UpdateUnit="$(UpdateIntervalUnits)"
            />
        <Message Text="(out) DeployManifest: '@(DeployManifest)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

        <CreateProperty Value="true">
            <Output TaskParameter="Value" PropertyName="CopyApplicationManifest" />
        </CreateProperty>
        <Message Text="(out) CopyApplicationManifest: '$(CopyApplicationManifest)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

    </Target>


    <!--
    Compute the paths to the intermediate satellite assemblies,
    with culture attributes so we can copy them to the right place
    -->
    <Target
        Name="ComputeIntermediateSatelliteAssemblies"
        Condition="'@(ManifestResourceWithCulture)@(ManifestNonResxWithCultureOnDisk)'!=''"
     >
        <CreateItem
              Include="$(IntermediateOutputPath)%(Culture)\$(TargetName).resources.dll"
              AddAttributeName="Culture"
              AddAttributeValue="%(Culture)"
              Condition="'@(ManifestResourceWithCulture)@(ManifestNonResxWithCulture)' != ''">

              <Output TaskParameter="Include" ItemName="IntermediateSatelliteAssemblies"/>
        </CreateItem>
    </Target>

    <!--
    Copy references that are marked as "CopyLocal" and their dependencies, including .pdbs, .xmls and satellites.
    -->
    <Target
        Name="CopyCopyLocalFilesToOutputDirectory">

        <Copy
            SourceFiles="@(ReferenceCopyLocalPaths)"
            DestinationFiles="@(ReferenceCopyLocalPaths->'$(OutDir)%(DestinationSubDirectory)\%(Filename)%(Extension)')"
            SkipUnchangedFiles="true"
            />

    </Target>

    <!--
    Create a list of items that have the CopyToOutputDirectory attribute set to 'true'.
    -->
    <Target
        Name="CreateCopyToOutputDirectoryItems"
        DependsOnTargets="AssignTargetPaths"
        >
            <CreateItem Include="@(ContentWithTargetPath);@(EmbeddedResourceWithTargetPath);@(CompileWithTargetPath);@(NoneWithTargetPath)">
                <Output TaskParameter="Include" ItemName="AllItemsWithTargetPath"/>
            </CreateItem>
                
            <CreateItem
                Include="@(AllItemsWithTargetPath)"
                Condition="'%(AllItemsWithTargetPath.CopyToOutputDirectory)'=='True'"
                >
                
                <Output TaskParameter="Include" ItemName="CopyToOutputDirectoryFiles"/>
                
            </CreateItem>
    </Target>

    <!--
    Copy files that have the CopyToOutputDirectory attribute set to 'true'.
    -->
    <Target
        Name="CopyCopyToOutputDirectoryFiles"
        Inputs="@(CopyToOutputDirectoryFiles)"
        Outputs="$(OutputPath)%(TargetPath)"
        DependsOnTargets="CreateCopyToOutputDirectoryItems"
        >

        <Copy
            SourceFiles = "@(CopyToOutputDirectoryFiles)"
            DestinationFiles = "$(OutputPath)%(TargetPath)"
            />

    </Target>

    <!--
    Copy all build outputs, satellites and other necessary files to the final directory.
    -->
    <Target
        Name="CopyFilesToOutputDirectory"
        DependsOnTargets="ComputeIntermediateSatelliteAssemblies;CopyCopyLocalFilesToOutputDirectory;CopyCopyToOutputDirectoryFiles">

        <!-- Copy the build product (.dll or .exe). -->
        <Copy
            SourceFiles="@(IntermediateAssembly)"
            DestinationFiles="$(OutDir)$(TargetFileName)"
            SkipUnchangedFiles="true"
            >

            <Output ItemName="MainAssembly" TaskParameter="DestinationFiles" />
        </Copy>

        <!-- Mini-clean.  Delete the destination PDB from the last build.  If DebugInformation
             has been turned off, then we may not end up copying a new PDB on top of it. -->
        <Delete Files="$(OutDir)$(TargetName).pdb"/>
        
        <!-- Copy the debug information file (.pdb), if any -->
        <Copy
            SourceFiles="$(IntermediateOutputPath)$(TargetName).pdb"
            DestinationFiles="$(OutDir)$(TargetName).pdb"
            SkipUnchangedFiles="true"
            Condition="Exists('$(IntermediateOutputPath)$(TargetName).pdb')"
            />

        <!-- Copy the resulting XML documentation file, if any. -->
        <Copy
            SourceFiles="$(DocFile)"
            DestinationFiles="@(FinalDocFile)"
            SkipUnchangedFiles="true"
            Condition="Exists('$(DocFile)')"
        />

        <!-- Copy the application's .config file, if any. -->
        <Copy
            SourceFiles="@(AppConfigWithTargetPath)"
            DestinationFiles="$(OutDir)%(TargetPath)"
            SkipUnchangedFiles="true"
        />

        <!-- Copy satellite assemblies. -->
        <Copy
            SourceFiles="@(IntermediateSatelliteAssemblies)"
            DestinationFiles="@(IntermediateSatelliteAssemblies->'$(OutDir)%(Culture)\$(TargetName).resources.dll')"
            SkipUnchangedFiles="true"
            />

        <!-- Copy COM reference wrappers if any. -->
        <Copy
            SourceFiles="@(ReferenceComWrappersToCopyLocal)"
            DestinationFolder="$(OutDir)"
            SkipUnchangedFiles="true"
            />

        <!-- Copy isolated COM references, if any. -->
        <Copy
            SourceFiles="@(ResolvedIsolatedComModules)"
            DestinationFolder="$(OutDir)"
            SkipUnchangedFiles="true"
            />

        <!-- Copy COM references included by native (manifest) references, if any. -->
        <Copy
            Condition="'@(LooseManifestFile)'!=''"
            SourceFiles="@(LooseManifestFile)"
            DestinationFolder="$(OutDir)"
            SkipUnchangedFiles="true"
            />

        <!-- Copy native (manifest) reference files themselves, if any. -->
        <Copy
            Condition="'@(NativeReferenceFile)'!=''"
            SourceFiles="@(NativeReferenceFile)"
            DestinationFolder="$(OutDir)"
            SkipUnchangedFiles="true"
            />

        <!-- Copy the built manifests (.exe.manifest, .application) to the final directory. -->
        <Copy
            Condition="'$(CopyApplicationManifest)'=='true'"
            SourceFiles="@(ApplicationManifest)"
            DestinationFolder="$(OutDir)"
            SkipUnchangedFiles="true"
            />
        <Copy
            Condition="'$(GenerateClickOnceManifests)'=='true'"
            SourceFiles="@(DeployManifest)"
            DestinationFolder="$(OutDir)"
            SkipUnchangedFiles="true"
            />


    </Target>

    <!--
    Delete the empty source file if one was created at the start of the build.
    -->
    <Target
        Name="RemoveEmptyGeneratedSource"
        Condition="Exists('$(IntermediateOutputPath)VisualStudio.Empty$(DefaultLanguageSourceExtension)')"
        >

        <Delete
            Files="$(IntermediateOutputPath)VisualStudio.Empty$(DefaultLanguageSourceExtension)"/>

    </Target>

    <PropertyGroup>
        <UnmanagedRegistrationDependsOn></UnmanagedRegistrationDependsOn>
    </PropertyGroup>
    <Target
        Name="UnmanagedRegistration"
        Condition="'$(RegisterForComInterop)_and_$(OutputType)'=='true_and_library'"
        DependsOnTargets="$(UnmanagedRegistrationDependsOn)"
        >

        <RegisterAssembly
            Assemblies="@(OutputPathItem->'%(FullPath)$(TargetFileName)')"
            TypeLibFiles="@(OutputPathItem->'%(FullPath)$(TargetName).tlb')"
            CreateCodeBase="true"
        />

    </Target>

    <Target
      Name="RunFxCop"
      Condition="'$(RunFxCop)'=='true'"
      Inputs="$(IntermediateOutputPath)$(TargetName)$(TargetExt)"
      Outputs="$(IntermediateOutputPath)FxCopLog.xml;$(IntermediateOutputPath)$(TargetName).FxCop"
      DependsOnTargets="Compile"
    >
      <FxCop
        ToolPath="$(FxCopDir)"
        Assemblies="$(IntermediateOutputPath)$(TargetName)$(TargetExt)"
        Rules="$(FxCopRules)"
        SynthesizedProject="$(IntermediateOutputPath)$(TargetName).FxCop"
        LogFile="$(IntermediateOutputPath)FxCopLog.xml"
        ExclusionsFile="$(FxCopExclusionsFile)"
      />
    </Target>

    <!--
    Run the post-build event if there is one.
    -->
    <PropertyGroup>
        <PostBuildEventDependsOn></PostBuildEventDependsOn>
    </PropertyGroup>
    <Target
        Name="PostBuildEvent"
        Condition="'$(PostBuildEvent)'!=''"
        DependsOnTargets="$(PostBuildEventDependsOn)"
        >

        <Exec
              WorkingDirectory="$(OutDir)"
              Command="$(PostBuildEvent)" />

    </Target>

    <!--
    Prepare the names of resource files.
    -->
    <PropertyGroup>
        <PrepareResourceNamesDependsOn>
            SplitResourcesByCulture;CreateManifestResourceNames
        </PrepareResourceNamesDependsOn>
    </PropertyGroup>
    <Target
        Name="PrepareResourceNames"
        DependsOnTargets="$(PrepareResourceNamesDependsOn)"
        />

    <!--
    Prepare resources for the Compile step.
    -->
    <PropertyGroup>
        <PrepareResourcesDependsOn>
            PrepareResourceNames;CopyNonResxEmbeddedResources;ResGen;CompileLicxFiles
        </PrepareResourcesDependsOn>
    </PropertyGroup>
    <Target
        Name="PrepareResources"
        DependsOnTargets="$(PrepareResourcesDependsOn)"
        />

    <!--
    Copy the build outputs to the final directory if they have changed.
    -->
    <PropertyGroup>
        <PrepareForRunDependsOn>
            RemoveEmptyGeneratedSource;
            CopyFilesToOutputDirectory
        </PrepareForRunDependsOn>
    </PropertyGroup>
    <Target
        Name="PrepareForRun"
        DependsOnTargets="$(PrepareForRunDependsOn)"
        />

    <!--
    Delete all intermediate and final build outputs.
    -->
    <PropertyGroup>
        <CleanDependsOn>
            PrepareResourceNames;
            UnmanagedUnregistration
        </CleanDependsOn>
    </PropertyGroup>
    <Target
        Name="Clean"
        DependsOnTargets="$(CleanDependsOn)"
        >

        <Delete
            Files=
            "$(OutDir)$(TargetFileName).config;
             $(OutDir)$(TargetFileName);
             $(OutDir)$(TargetName).pdb;
             @(FinalDocFile);
             $(IntermediateOutputPath)$(TargetFileName);
             $(IntermediateOutputPath)$(TargetName).pdb;
             @(ManifestNonResxWithNoCulture->'$(IntermediateOutputPath)%(Identity)');
             @(ManifestNonResxWithCulture->'$(IntermediateOutputPath)%(Identity)');
             @(ManifestResourceWithNoCultureName->'$(IntermediateOutputPath)%(Identity).resources');
             @(ManifestResourceWithCultureName->'$(IntermediateOutputPath)%(Identity).resources');
             @(DocFileItem);
             $(IntermediateOutputPath)ResolveAssemblyReference.cache;
             $(IntermediateOutputPath)ResGen.cache;
             $(IntermediateOutputPath)$(TargetFileName).licenses"
             />

        <Delete
            Files=
            "$(OutDir)%(ManifestNonResxWithCulture.Culture)\$(TargetName).resources.dll;
             $(IntermediateOutputPath)%(ManifestNonResxWithCulture.Culture)\$(TargetName).resources.dll"
             />

        <Delete
            Files=
            "$(OutDir)%(ManifestResourceWithCultureName.Culture)\$(TargetName).resources.dll;
             $(IntermediateOutputPath)%(ManifestResourceWithCultureName.Culture)\$(TargetName).resources.dll"
             />

    </Target>

    <!--
    Delete all intermediate and final build outputs.
    -->
    <PropertyGroup>
        <RebuildDependsOn>
            Clean;
            Build
        </RebuildDependsOn>
    </PropertyGroup>
    <Target
        Name="Rebuild"
        DependsOnTargets="$(RebuildDependsOn)"
        />

    <!--
    This stand-alone target returns the name of the build product (i.e. EXE, DLL)
    that would be produced if we built this project.
    -->
    <Target
        Name="MainBuiltProjectOutputGroup"
        Outputs="$(TargetPath)"
        />

    <!--
    Dump the names of certain important properties.
    -->
    <Target
        Name="DumpSpecialMacros"
        Condition="'$(MSBuildTargetsVerbose)'=='true'"
        >

        <Message Text="ConfigurationName  =$(ConfigurationName)"/>
        <Message Text="DevEnvDir          =$(DevEnvDir)"/>
        <Message Text="OutDir             =$(OutDir)"/>
        <Message Text="PlatformName       =$(PlatformName)"/>
        <Message Text="ProjectExt         =$(ProjectExt)"/>
        <Message Text="ProjectFileName    =$(ProjectFileName)"/>
        <Message Text="ProjectName        =$(ProjectName)"/>
        <Message Text="SolutionDir        =$(SolutionDir)"/>
        <Message Text="SolutionExt        =$(SolutionExt)"/>
        <Message Text="SolutionFileName   =$(SolutionFileName)"/>
        <Message Text="SolutionName       =$(SolutionName)"/>
        <Message Text="SolutionPath       =$(SolutionPath)"/>
        <Message Text="TargetExt          =$(TargetExt)"/>
        <Message Text="TargetFileName     =$(TargetFileName)"/>
        <Message Text="TargetName         =$(TargetName)"/>
        <Message Text="MSBuildAllProjects =$(MSBuildAllProjects)"/>
        <Message Text="FxCopDir            =$(FxCopDir)"/>

        <Message Text="ProjectDir"/>
        <Message Text="$(ProjectDir)"/>
        <Message Text="ProjectPath"/>
        <Message Text="$(ProjectPath)"/>
        <Message Text="TargetDir"/>
        <Message Text="$(TargetDir)"/>
        <Message Text="TargetPath"/>
        <Message Text="$(TargetPath)"/>

    </Target>

    <PropertyGroup>
        <PublishDependsOn Condition="'$(PublishDependsOn)'==''">Build</PublishDependsOn>
    </PropertyGroup>
    <Target
        Name="Publish"
        DependsOnTargets="$(PublishDependsOn)"
        >

        <!-- Copy manifest files -->
        <Message Text="(in) ApplicationManifest: '@(ApplicationManifest)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) ManifestEntryPoint: '@(ManifestEntryPoint)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) ManifestDependencies: '@(ManifestDependencies)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) ManifestSatellites: '@(ManifestSatellites)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) ManifestFiles: '@(ManifestFiles)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Copy
            SourceFiles="@(ManifestEntryPoint);
                         @(ManifestDependencies);
                         @(ManifestFiles);
                         @(ApplicationManifest);
                         @(ManifestSatellites)"
            DestinationFiles="$(PublishDir)$(AssemblyName)_$(ManifestVersion)\%(TargetPath)"
            SkipUnchangedFiles="true"
            />

        <!-- Copy COM files -->
        <Message Text="(in) @(ReferenceComWrappersToCopyLocal): '@(ReferenceComWrappersToCopyLocal)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) @(ResolvedIsolatedComModules): '@(ResolvedIsolatedComModules)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) @(NativeReferenceFile): '@(NativeReferenceFile)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Message Text="(in) @(LooseManifestFile): '@(LooseManifestFile)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <Copy
            SourceFiles="@(ReferenceComWrappersToCopyLocal);@(ResolvedIsolatedComModules);@(NativeReferenceFile);@(LooseManifestFile)"
            DestinationFolder="$(PublishDir)$(AssemblyName)_$(ManifestVersion)"
            SkipUnchangedFiles="true"
            />

        <!-- Update entry point path in deploy manifest and resign -->
        <Message Text="(in) DeployManifest: '@(DeployManifest)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <UpdateManifest
            ApplicationPath="$(AssemblyName)_$(ManifestVersion)\$(TargetApplicationManifestFileName)"
            CertificateFile="$(CertificateFile)"
            CertificatePassword="$(CertificatePassword)"
            DelaySign="$(DelaySign)"
            InputManifest="@(DeployManifest)"
            KeyContainer="$(ManifestKeyContainerName)"
            KeyFile="$(ManifestKeyOriginatorFile)"
            KeyProvider="$(KeyProviderName)"
            OutputManifest="$(PublishDir)$(TargetDeployManifestFileName)"
            >
            <Output TaskParameter="OutputManifest" ItemName="PublishedDeployManifest"/>
        </UpdateManifest>
        <Message Text="(out) PublishedDeployManifest: '$(PublishedDeployManifest)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

        <Message Text="(in) ApplicationUrl: '$(ApplicationUrl)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <FormatUrl
            InputUrl="$(ApplicationUrl)"
            >
            <Output TaskParameter="OutputUrl" PropertyName="FormattedApplicationUrl"/>
        </FormatUrl>
        <Message Text="(out) FormattedApplicationUrl: '$(FormattedApplicationUrl)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

        <Message Text="(in) ComponentsUrl: '$(ComponentsUrl)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <FormatUrl
            InputUrl="$(ComponentsUrl)"
            >
            <Output TaskParameter="OutputUrl" PropertyName="FormattedComponentsUrl"/>
        </FormatUrl>
        <Message Text="(out) FormattedComponentsUrl: '$(FormattedComponentsUrl)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

        <!-- Build setup.exe bootstrapper and copy referenced packages -->
        <Message Text="(in) BootstrapperFile: '@(BootstrapperFile)'" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
        <GenerateBootstrapper
            Condition="'$(BootstrapperEnabled)'=='true'"
            ApplicationFile="$(TargetDeployManifestFileName)"
            ApplicationName="$(AssemblyName)"
            ApplicationUrl="$(FormattedApplicationUrl)"
            BootstrapperItems="@(BootstrapperFile)"
            ComponentsUrl="$(FormattedComponentsUrl)"
            Culture="$(TargetCulture)"
            FallbackCulture="$(FallbackCulture)"
            OutputPath="$(PublishDir)"/>

    </Target>

    <!--
    If post-built events are set to fire "OnOutputUpdated" then take before
    and after timestamps so that we can compare them.
    -->
    <Target
        Name="TimeStampBeforeCompile"
        Condition="'$(RunPostBuildEvent)'=='OnOutputUpdated'"
        >

        <CreateItem Include="%(IntermediateAssembly.ModifiedTime)">
            <Output TaskParameter="Include" ItemName="IntermediateAssemblyBeforeTimeStamp"/>
        </CreateItem>
    </Target>

    <Target
        Name="TimeStampAfterCompile"
        Condition="'$(RunPostBuildEvent)'=='OnOutputUpdated'"
        >

        <CreateItem Include="%(IntermediateAssembly.ModifiedTime)">
            <Output TaskParameter="Include" ItemName="IntermediateAssemblyAfterTimeStamp"/>
        </CreateItem>
    </Target>

    <Target Name="ObjectRelationalValidator"
        Condition=" '@(MappingSchemaFile)@(EmbeddedMappingSchemaFile)' != '' "
        DependsOnTargets="AssignTargetPaths"
        >
        <Microsoft.VisualStudio.EnterpriseTools.MappingTool.CompileTime.ObjectRelationalValidator
            ProjectReferences="@(ReferencePath)"
            ProjectTarget="$(TargetPath)"
            MappingSchemaFiles="@(MappingSchemaFile);@(EmbeddedMappingSchemaFile)"
            ProjectDirectory="$(ProjectDir)"
            />
    </Target>


    <!--
    Run the final build output.
    -->
    <PropertyGroup>
        <RunDependsOn></RunDependsOn>
    </PropertyGroup>
    <Target
        Name="Run"
        DependsOnTargets="$(RunDependsOn)"
        >
        <Error Text="Cannot run '$(TargetPath)' because project output type is not '.exe'" Condition="'$(TargetExt)'!='.exe'"/>
        <Exec Command="$(TargetPath)"/>
    </Target>

    <!--
    The core build step calls each of the build targets.
    -->
    <PropertyGroup>
        <CoreBuildDependsOn>
            BuildOnlySettings;
            PrepareForBuild;
            PreBuildEvent;
            UnmanagedUnregistration;
            ResolveReferences;
            PrepareResources;
            ResolveKeySource;
            TimeStampBeforeCompile;
            Compile;
            TimeStampAfterCompile;
            CreateSatelliteAssemblies;
            BuildManifests;
            PrepareForRun;
            ObjectRelationalValidator;
            UnmanagedRegistration;
            RunFxCop;
            DumpSpecialMacros
        </CoreBuildDependsOn>
    </PropertyGroup>
    <Target
        Name="CoreBuild"
        DependsOnTargets="$(CoreBuildDependsOn)"
        >

        <OnError Condition="'$(RunPostBuildEvent)'=='Always'" ExecuteTargets="PostBuildEvent"/>
        <OnError ExecuteTargets="PostBuildOnOutputChange"/>

     </Target>

    <!--
    The following targets are needed to support post-build. These steps are driven by two parameters.

    (1) The $(RunPostBuildEvent) property is set by the user through VS and can be one of four values.

        - OnBuildSuccess: In this case, every step of the build must succeed for the post-build step to run.
        - <Blank>: This is the same as OnBuildSuccess.
        - OnOutputUpdated: In this case, the post-build step will run only if the main output assembly was
        actually updated.
        - Always: The post-build step is always run.

    (2) The @(IntermediateAssemblyBeforeTimeStamp) and @(IntermediateAssemblyAfterTimeStamp) values are
        set by the TimeStampBeforeCompile and TimeStampAfterCompile targets.  If the assembly was actually
        rebuilt during this build, then the two values will be different.
    -->
    <Target
        Name="PostBuildOnSuccess"
        Condition="'$(RunPostBuildEvent)'!='OnOutputUpdated'"
        DependsOnTargets="PostBuildEvent"/>

    <Target
        Name="PostBuildOnOutputChangeCheckTimestamps"
        Condition="'@(IntermediateAssemblyBeforeTimeStamp)'!='@(IntermediateAssemblyAfterTimeStamp)'"
        DependsOnTargets="PostBuildEvent"/>

    <Target
        Name="PostBuildOnOutputChange"
        Condition="'$(RunPostBuildEvent)'=='OnOutputUpdated'"
        DependsOnTargets="PostBuildOnOutputChangeCheckTimestamps"/>

    <Target
        Name="CoreBuildSucceeded"
        DependsOnTargets="PostBuildOnSuccess;PostBuildOnOutputChange"/>

    <!--
    This target is used by the UpToDateCheck target in order to compute the
    list of satellite assemblies that will be built by this project.
    -->
    <Target Name="ComputeSatelliteAssemblies"
            DependsOnTargets="PrepareResourceNames">

        <CreateItem
              Include="$(OutDir)%(Culture)\$(TargetName).resources.dll"
              Condition="'@(ResxWithCulture)@(NonResxWithCulture)' != ''">

              <Output TaskParameter="Include" ItemName="SatelliteAssembly"/>
        </CreateItem>

    </Target>

    <!--
    ResX files can contain "linked" items which are not necessairly listed
    as items in the project.  This target, used by the UpToDateCheck target,
    collects all such files so that we can do timestamp checking on them.
    -->
    <Target Name="GetLinkedFilesFromResX"
            DependsOnTargets="PrepareResourceNames">

        <GetLinkedFilesFromResX
              StateFile="$(IntermediateOutputPath)ResGen.cache"
              UseSourcePath="$(UseSourcePath)"
              Sources="@(ResxWithCulture);@(ResxWithNoCulture)"
              Condition="'@(ResxWithCulture)@(ResxWithNoCulture)' != ''">

            <Output TaskParameter="LinkedFiles" ItemName="LinkedResXFiles" />

        </GetLinkedFilesFromResX>

    </Target>

    <!--
    This target performs an up-to-date check on behalf of the IDE.  The target
    performs timestamp checking of all known inputs against all known outputs.

    This target will copy referenced assemblies into the output directory if
    they are not already there.
    -->
    <Target Name="UpToDateCheck"
            Inputs="@(Compile);
                @(EmbeddedResource);
                @(LinkedResXFiles);
                @(Content);
                @(None);
                $(MSBuildAllProjects);
                $(MSBuildProjectFullPath).user;
                @(ReferencePath);
                @(ResolvedProjectReferencePaths);
                $(ApplicationIcon);
                $(AssemblyOriginatorKeyFile)"
            Outputs="$(TargetPath);@(SatelliteAssembly)"
            DependsOnTargets="BuildOnlySettings;
                              ResolveReferences;
                              ComputeSatelliteAssemblies;
                              GetLinkedFilesFromResX;
                              CopyCopyLocalFilesToOutputDirectory;
                              AssignTargetPaths">

            <CreateProperty Value="false">
                <Output PropertyName="UpToDate" TaskParameter="ValueSetByTask"/>
            </CreateProperty>
    </Target>

    <!--
    The targets below drive output groups, which provide generic information about a
    project's inputs (e.g., content files, compilation sources, etc.) and built outputs
    (e.g., built EXE/DLL, PDB, XML documentation files, etc.)

    Each target may produce two kinds of items:  outputs and dependencies.  Outputs are
    items from the current project; dependencies are items that are brought into the
    current project as a result of referencing other projects or components.

    Output items must be named "{TargetName}Output".  Dependency items must be named
    "{TargetName}Dependency".  For both outputs and dependencies, the Include attribute
    specifies the location of the output/dependency; it must be a full path.  Any number
    of additional attributes may be placed on an output/dependency item.
    -->

    <!--
    This target performs population of the Built project output group.
    -->
    <Target Name="PrepareForProjectBuiltOutputGroupPopulation">
        <MakeDir Directories="$(IntermediateOutputPath)"/>
    </Target>

    <ItemGroup>
        <BuiltProjectOutputGroupMainOutput1 Include="@(IntermediateAssembly->'%(FullPath)')">
            <IsKeyOutput>true</IsKeyOutput>
            <InProject>false</InProject>
        </BuiltProjectOutputGroupMainOutput1>
    </ItemGroup>

    <Target Name="BuiltProjectOutputGroup"
            DependsOnTargets="PrepareForProjectBuiltOutputGroupPopulation"
            Outputs="@(BuiltProjectOutputGroupOutput->'%(FullPath)')"
            >

        <!-- This item represents the main built output -->
        <CreateItem Include="@(BuiltProjectOutputGroupMainOutput1)" AddAttributeName="OUTPUTLOC" AddAttributeValue="$(TargetPath)">
            <Output ItemName="BuiltProjectOutputGroupMainOutput2" TaskParameter="Include"/>
        </CreateItem>

        <CreateItem Include="@(BuiltProjectOutputGroupMainOutput2)" AddAttributeName="TargetPath" AddAttributeValue="$(TargetFileName)">
            <Output ItemName="BuiltProjectOutputGroupMainOutput3" TaskParameter="Include"/>
        </CreateItem>

        <CreateItem Include="@(BuiltProjectOutputGroupMainOutput3)" AddAttributeName="COM2REG" AddAttributeValue="true"
              Condition="'$(RegisterForComInterop)_and_$(OutputType)'=='true_and_library'">
            <Output ItemName="BuiltProjectOutputGroupOutputIntermediate" TaskParameter="Include"/>
        </CreateItem>

        <CreateItem Include="@(BuiltProjectOutputGroupMainOutput3)"
              Condition="'$(RegisterForComInterop)_and_$(OutputType)'!='true_and_library'">
            <Output ItemName="BuiltProjectOutputGroupOutputIntermediate" TaskParameter="Include"/>
        </CreateItem>

        <!-- This item represents the app.config file -->
        <CreateItem Include="@(AppConfigWithTargetPath)" AddAttributeName="OUTPUTLOC" AddAttributeValue="$(TargetDir)%(TargetPath)">
            <Output ItemName="BuiltProjectOutputGroupOutputIntermediate" TaskParameter="Include"/>
        </CreateItem>

        <!-- This item represents the native manifest, example: WindowsApplication1.exe.manifest or Native.ClassLibrary1.manifest -->
        <CreateItem Include="@(COMReference)"
              Condition=" '%(COMReference.Isolated)' == 'true' ">

            <Output ItemName="IsolatedComReference" TaskParameter="Include"/>
        </CreateItem>

        <CreateItem Include="$(OutDir)$(TargetApplicationManifestFileName)"
                    AddAttributeName="TargetPath" AddAttributeValue="$(TargetApplicationManifestFileName)"
                    Condition="'@(NativeReference)@(IsolatedComReference)'!=''">
            <Output ItemName="BuiltProjectOutputGroupOutputIntermediate" TaskParameter="Include"/>
        </CreateItem>

        <!-- Convert intermediate items into final items; this way we can get the full path for each item -->
        <CreateItem Include="@(BuiltProjectOutputGroupOutputIntermediate->'%(FullPath)')">
            <Output ItemName="BuiltProjectOutputGroupOutput" TaskParameter="Include"/>
        </CreateItem>

        <Message Text="Built Output Group Outputs:  @(BuiltProjectOutputGroupOutput)" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

    </Target>


    <!--
    This target performs population of the Debug Symbols project output group.
    -->
    <Target
        Name="DebugSymbolsProjectOutputGroup"
        Outputs="@(DebugSymbolsProjectOutputGroupOutput->'%(FullPath)')"
        Condition="'$(DebugSymbols)'!='false'">

        <!-- This item represents the PDB built by the project -->

        <CreateItem Include="$(IntermediateOutputPath)$(TargetName).pdb" AddAttributeName="OUTPUTLOC" AddAttributeValue="@(OutputPathItem->'%(FullPath)$(TargetName).pdb')">
            <Output ItemName="DebugSymbolsProjectOutputGroup1" TaskParameter="Include"/>
        </CreateItem>

        <CreateItem Include="@(DebugSymbolsProjectOutputGroup1)" AddAttributeName="TargetPath" AddAttributeValue="$(TargetName).pdb">
            <Output ItemName="DebugSymbolsProjectOutputGroupOutputIntermediate" TaskParameter="Include"/>
        </CreateItem>

        <!-- Convert intermediate items into final items; this way we can get the full path for each item -->
        <CreateItem Include="@(DebugSymbolsProjectOutputGroupOutputIntermediate->'%(FullPath)')">
            <Output ItemName="DebugSymbolsProjectOutputGroupOutput" TaskParameter="Include"/>
        </CreateItem>

        <Message Text="Debug Symbols Output Group Outputs:  @(DebugSymbolsProjectOutputGroupOutput)" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

    </Target>

    <!--
        This target performs population of the Documentation project output group.
    -->
    <ItemGroup>
        <DocumentationProjectOutputGroup1 Include="$(DocFile)" Condition="'$(DocumentationFile)'!=''">
            <IsKeyOutput>true</IsKeyOutput>
            <InProject>false</InProject>
        </DocumentationProjectOutputGroup1>
    </ItemGroup>

    <Target
        Name="DocumentationProjectOutputGroup"
        Outputs="@(DocumentationProjectOutputGroupOutput->'%(FullPath)')"
        Condition="'$(DocumentationFile)'!=''">

        <!-- This item represents the XML file built by the project -->
        <CreateItem Include="@(DocumentationProjectOutputGroup1)" AddAttributeName="OUTPUTLOC" AddAttributeValue="@(FinalDocFile)">
            <Output ItemName="DocumentationProjectOutputGroup2" TaskParameter="Include"/>
        </CreateItem>

        <CreateItem Include="@(DocumentationProjectOutputGroup2)" AddAttributeName="TargetPath" AddAttributeValue="@(DocFileItem->'%(Filename)%(Extension)')">
            <Output ItemName="DocumentationProjectOutputGroupOutputIntermediate" TaskParameter="Include"/>
        </CreateItem>

        <!-- Convert intermediate items into final items; this way we can get the full path for each item -->
        <CreateItem Include="@(DocumentationProjectOutputGroupOutputIntermediate->'%(FullPath)')">
            <Output ItemName="DocumentationProjectOutputGroupOutput" TaskParameter="Include"/>
        </CreateItem>

        <Message Text="Documentation Outputs:  @(DocumentationProjectOutputGroupOutput)" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

    </Target>

    <!--
    This target performs population of the Satellite Files project output group.
    -->
    <Target
            Name="SatelliteDllsProjectOutputGroup"
            DependsOnTargets="PrepareResourceNames"
            Outputs="@(SatelliteDllsProjectOutputGroupOutput->'%(FullPath)')">

        <CreateItem
              Include="$(IntermediateOutputPath)%(ResxWithCulture.Culture)\$(TargetName).resources.dll"
              AddAttributeName="TargetPath"
              AddAttributeValue="%(ResxWithCulture.Culture)\$(TargetName).resources.dll"
              Condition="'@(ResxWithCulture)' != ''">

              <Output ItemName="SatelliteDllsProjectOutputGroupOutputIntermediate" TaskParameter="Include" />
        </CreateItem>

        <CreateItem
              Include="$(IntermediateOutputPath)%(NonResxWithCulture.Culture)\$(TargetName).resources.dll"
              AddAttributeName="TargetPath"
              AddAttributeValue="%(NonResxWithCulture.Culture)\$(TargetName).resources.dll"
              Condition="'@(NonResxWithCulture)' != ''">

              <Output ItemName="SatelliteDllsProjectOutputGroupOutputIntermediate" TaskParameter="Include" />
        </CreateItem>

        <CreateItem Include="$(IntermediateOutputPath)">
            <Output ItemName="SatelliteDllsProjectOutputGroupRootRelativeUrlBaseIntermediate" TaskParameter="Include"/>
        </CreateItem>

        <!-- Convert intermediate items into final items; this way we can get the full path for each item. -->
        <CreateItem Include="@(SatelliteDllsProjectOutputGroupOutputIntermediate->'%(FullPath)')">
            <Output ItemName="SatelliteDllsProjectOutputGroupOutput" TaskParameter="Include"/>
        </CreateItem>

        <Message Text="SatelliteDlls Outputs:  @(SatelliteDllsProjectOutputGroupOutput)" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

    </Target>

    <!--
    This target performs population of the Content Files project output group.
    Content files are items in the project whose type is "Content".
    -->
    <Target
        Name="ContentFilesProjectOutputGroup"
        Outputs="@(ContentFilesProjectOutputGroupOutput->'%(FullPath)')"
        DependsOnTargets="AssignTargetPaths">

        <!-- Convert items into final items; this way we can get the full path for each item. -->
        <CreateItem Include="@(ContentWithTargetPath->'%(FullPath)')">
            <Output ItemName="ContentFilesProjectOutputGroupOutput" TaskParameter="Include"/>
        </CreateItem>

        <Message Text="Content Files Outputs:  @(ContentFilesProjectOutputGroupOutput)" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

    </Target>

    <!--
    This target performs population of the Source Files project output group.
    Source files are items in the project whose type is "Compile" and "EmbeddedResource".

    Note:  the source files output group also includes the project file as well
    as the Application Config File - but only provided that the application configuration
    file's type is "None".
    -->
    <Target
        Name="SourceFilesProjectOutputGroup"
        Outputs="@(SourceFilesProjectOutputGroupOutput->'%(FullPath)')">

        <!-- First we deal with Compile, EmbeddedResource and AppConfig -->
        <CreateItem Include="@(CompileWithTargetPath);@(EmbeddedResourceWithTargetPath);@(AppConfigWithTargetPath)">
            <Output ItemName="SourceFilesProjectOutputGroupOutputIntermediate" TaskParameter="Include"/>
        </CreateItem>

        <!-- Include the project file -->
        <CreateItem Include="$(ProjectPath)" AddAttributeName="TargetPath" AddAttributeValue="$(ProjectFileName)">
            <Output ItemName="SourceFilesProjectOutputGroupOutputIntermediate" TaskParameter="Include"/>
        </CreateItem>

        <!-- Convert intermediate items into final items; this way we can get the full path for each item -->
        <CreateItem Include="@(SourceFilesProjectOutputGroupOutputIntermediate->'%(FullPath)')">
            <Output ItemName="SourceFilesProjectOutputGroupOutput" TaskParameter="Include"/>
        </CreateItem>

        <Message Text="Source Files Outputs:  @(SourceFilesProjectOutputGroupOutput)" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

    </Target>

    <Target Name="AllProjectOutputGroups"
            DependsOnTargets="BuiltProjectOutputGroup;DebugSymbolsProjectOutputGroup;
                              DocumentationProjectOutputGroup;SatelliteDllsProjectOutputGroup;
                              SourceFilesProjectOutputGroup;ContentFilesProjectOutputGroup"/>

    <!--
        This target performs population of the Built project output group dependencies.
    -->
    <Target Name="BuiltProjectOutputGroupDependencies"
            DependsOnTargets="ResolveReferences"
            Outputs="@(BuiltProjectOutputGroupDependency->'%(FullPath)')"
            >

        <!-- This item represents dependencies (resolved references) -->

        <CreateItem Include="@(ReferencePath->'%(FullPath)');@(ReferenceDependencyPaths->'%(FullPath)')">
            <Output ItemName="BuiltProjectOutputGroupDependency" TaskParameter="Include"/>
        </CreateItem>

        <CreateItem Include="@(NativeReferenceFile->'%(FullPath)')">
            <Output ItemName="BuiltProjectOutputGroupDependency" TaskParameter="Include"/>
        </CreateItem>

        <CreateItem Include="@(LooseManifestFile->'%(FullPath)')">
            <Output ItemName="BuiltProjectOutputGroupDependency" TaskParameter="Include"/>
        </CreateItem>

        <CreateItem Include="@(ResolvedIsolatedComModules->'%(FullPath)')">
            <Output ItemName="BuiltProjectOutputGroupDependency" TaskParameter="Include"/>
        </CreateItem>

        <Message Text="Built Output Group Dependencies:  @(BuiltProjectOutputGroupDependency)" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

    </Target>

    <!--
    This target performs population of the dependencies for the debug symbols project output group.
    -->
    <Target
        Name="DebugSymbolsProjectOutputGroupDependencies"
        DependsOnTargets="ResolveReferences"
        Outputs="@(DebugSymbolsProjectOutputGroupDependency->'%(FullPath)')"
        Condition="'$(DebugSymbols)'!='false'">

        <!-- This item represents dependent PDB's -->

        <CreateItem Include="@(ReferenceRelatedPaths)" Condition="'%(Extension)' == '.pdb'">
            <Output ItemName="DebugSymbolsProjectOutputGroupDependencyIntermediate" TaskParameter="Include"/>
        </CreateItem>


        <CreateItem Include="@(DebugSymbolsProjectOutputGroupDependencyIntermediate->'%(FullPath)')">
            <Output ItemName="DebugSymbolsProjectOutputGroupDependency" TaskParameter="Include"/>
        </CreateItem>

        <Message Text="Debug Symbols Output Group Dependencies:  @(DebugSymbolsProjectOutputGroupDependency)" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
    </Target>


    <!--
    This target performs population of the dependencies for the satellite files project output group.
    -->
    <Target
            Name="SatelliteDllsProjectOutputGroupDependencies"
            DependsOnTargets="ResolveReferences"
            Outputs="@(SatelliteDllsProjectOutputGroupDependency->'%(FullPath)')">

        <!-- This item represents dependent satellites -->

        <CreateItem Include="@(ReferenceSatellitePaths->'%(FullPath)')">
            <Output ItemName="SatelliteDllsProjectOutputGroupDependency" TaskParameter="Include"/>
        </CreateItem>

        <Message Text="SatelliteDlls Dependencies:  @(SatelliteDllsProjectOutputGroupDependency)" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>
    </Target>

    <!--
        This target performs population of the dependencies for the documentation project output group.
    -->
    <Target
        Name="DocumentationProjectOutputGroupDependencies"
        DependsOnTargets="ResolveReferences"
        Outputs="@(DocumentationProjectOutputGroupDependency->'%(FullPath)')"
        Condition="'$(DocumentationFile)'!=''">

        <!-- This item represents dependent XML's -->

        <CreateItem Include="@(ReferenceRelatedPaths)" Condition="'%(Extension)' == '.xml'">
            <Output ItemName="DocumentationProjectOutputGroupDependencyIntermediate" TaskParameter="Include"/>
        </CreateItem>

        <!-- Convert intermediate items into final items; this way we can get the full path for each item -->

        <CreateItem Include="@(DocumentationProjectOutputGroupDependencyIntermediate->'%(FullPath)')">
            <Output ItemName="DocumentationProjectOutputGroupDependency" TaskParameter="Include"/>
        </CreateItem>

        <Message Text="Documentation Dependencies:  @(DocumentationProjectOutputGroupDependency)" Condition="'$(MSBuildTargetsVerbose)'=='true'"/>

    </Target>

    <Target Name="AllProjectOutputGroupsDependencies"
            DependsOnTargets="BuildOnlySettings;BuiltProjectOutputGroupDependencies;DebugSymbolsProjectOutputGroupDependencies;
                              SatelliteDllsProjectOutputGroupDependencies;DocumentationProjectOutputGroupDependencies"/>
</Project>
